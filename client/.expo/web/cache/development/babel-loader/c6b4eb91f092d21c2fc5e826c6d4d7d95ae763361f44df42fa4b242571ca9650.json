{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { openDB } from 'idb';\nvar DB_NAME = 'featureFlagsDB';\nvar DB_VERSION = 1;\nvar STORE_NAME = 'flags';\nvar FLAGS_KEY = 'currentFlags';\nvar DEFAULT_FLAGS = {\n  firebaseDirectIntegration: false,\n  analyticsDirectIntegration: false,\n  documentsDirectIntegration: false\n};\nvar featureFlags = {};\nvar db = null;\nvar performanceTimers = {};\nvar initDatabase = function () {\n  var _ref = _asyncToGenerator(function* () {\n    if (db) return db;\n    db = yield openDB(DB_NAME, DB_VERSION, {\n      upgrade: function upgrade(db, oldVersion, newVersion, transaction) {\n        if (oldVersion < 1) {\n          var store = db.createObjectStore(STORE_NAME);\n        }\n      }\n    });\n    return db;\n  });\n  return function initDatabase() {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar loadFeatureFlags = function () {\n  var _ref2 = _asyncToGenerator(function* () {\n    try {\n      var _db = yield initDatabase();\n      var savedData = yield _db.get(STORE_NAME, FLAGS_KEY);\n      if (savedData && savedData.flags) {\n        featureFlags = _objectSpread(_objectSpread({}, DEFAULT_FLAGS), savedData.flags);\n        console.log('Feature flags loaded from IndexedDB:', featureFlags);\n      } else {\n        featureFlags = _objectSpread({}, DEFAULT_FLAGS);\n        console.log('No feature flags found in IndexedDB, using defaults:', featureFlags);\n        yield saveFeatureFlags();\n      }\n    } catch (error) {\n      console.error('Error loading feature flags from IndexedDB:', error);\n      featureFlags = _objectSpread({}, DEFAULT_FLAGS);\n      console.log('Falling back to default feature flags due to IndexedDB error:', featureFlags);\n    }\n  });\n  return function loadFeatureFlags() {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar saveFeatureFlags = function () {\n  var _ref3 = _asyncToGenerator(function* () {\n    try {\n      var _db2 = yield initDatabase();\n      var timestamp = new Date().toISOString();\n      var auditInfo = {\n        timestamp: timestamp,\n        userId: 'anonymous'\n      };\n      var dataToSave = {\n        flags: featureFlags,\n        version: DB_VERSION,\n        audit: auditInfo\n      };\n      yield _db2.put(STORE_NAME, dataToSave, FLAGS_KEY);\n      console.log('Feature flags saved to IndexedDB:', featureFlags);\n      localStorage.setItem(LOCAL_STORAGE_KEY_SIGNAL, Date.now().toString());\n    } catch (error) {\n      console.error('Error saving feature flags to IndexedDB:', error);\n    }\n  });\n  return function saveFeatureFlags() {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar LOCAL_STORAGE_KEY_SIGNAL = 'featureFlagsChangeSignal';\nwindow.addEventListener('storage', function (event) {\n  if (event.key === LOCAL_STORAGE_KEY_SIGNAL) {\n    console.log('Feature flags change signaled from another tab. Reloading...');\n    loadFeatureFlags();\n  }\n});\nloadFeatureFlags();\nvar trackFeatureUsage = function trackFeatureUsage(featureName) {\n  console.log(`[Feature Flag Usage] Checked: ${featureName}`);\n};\nexport var startPerformanceTimer = function startPerformanceTimer(featureName) {\n  if (typeof performance !== 'undefined' && performance.now) {\n    performanceTimers[featureName] = performance.now();\n    console.log(`[Feature Flag Performance] Timer started for: ${featureName}`);\n  } else {\n    console.warn('[Feature Flag Performance] Performance timing not available.');\n  }\n};\nexport var stopPerformanceTimer = function stopPerformanceTimer(featureName) {\n  if (typeof performance !== 'undefined' && performance.now && performanceTimers[featureName]) {\n    var duration = performance.now() - performanceTimers[featureName];\n    console.log(`[Feature Flag Performance] Timer stopped for: ${featureName}, Duration: ${duration.toFixed(2)}ms`);\n    delete performanceTimers[featureName];\n  } else if (typeof performance !== 'undefined' && performance.now) {\n    console.warn(`[Feature Flag Performance] Timer not found for: ${featureName}`);\n  }\n};\nexport var isFeatureEnabled = function isFeatureEnabled(featureName) {\n  trackFeatureUsage(featureName);\n  return !!featureFlags[featureName];\n};\nexport var enableFeature = function () {\n  var _ref4 = _asyncToGenerator(function* (featureName) {\n    if (featureFlags[featureName] === true) {\n      console.log(`Feature \"${featureName}\" is already enabled.`);\n      return;\n    }\n    featureFlags = _objectSpread(_objectSpread({}, featureFlags), {}, _defineProperty({}, featureName, true));\n    console.log(`Feature \"${featureName}\" enabled.`);\n    yield saveFeatureFlags();\n  });\n  return function enableFeature(_x) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nexport var disableFeature = function () {\n  var _ref5 = _asyncToGenerator(function* (featureName) {\n    if (featureFlags[featureName] === false) {\n      console.log(`Feature \"${featureName}\" is already disabled.`);\n      return;\n    }\n    featureFlags = _objectSpread(_objectSpread({}, featureFlags), {}, _defineProperty({}, featureName, false));\n    console.log(`Feature \"${featureName}\" disabled.`);\n    yield saveFeatureFlags();\n  });\n  return function disableFeature(_x2) {\n    return _ref5.apply(this, arguments);\n  };\n}();\nexport var getAllFeatureFlags = function getAllFeatureFlags() {\n  return _objectSpread({}, featureFlags);\n};","map":{"version":3,"names":["openDB","DB_NAME","DB_VERSION","STORE_NAME","FLAGS_KEY","DEFAULT_FLAGS","firebaseDirectIntegration","analyticsDirectIntegration","documentsDirectIntegration","featureFlags","db","performanceTimers","initDatabase","_ref","_asyncToGenerator","upgrade","oldVersion","newVersion","transaction","store","createObjectStore","apply","arguments","loadFeatureFlags","_ref2","savedData","get","flags","_objectSpread","console","log","saveFeatureFlags","error","_ref3","timestamp","Date","toISOString","auditInfo","userId","dataToSave","version","audit","put","localStorage","setItem","LOCAL_STORAGE_KEY_SIGNAL","now","toString","window","addEventListener","event","key","trackFeatureUsage","featureName","startPerformanceTimer","performance","warn","stopPerformanceTimer","duration","toFixed","isFeatureEnabled","enableFeature","_ref4","_defineProperty","_x","disableFeature","_ref5","_x2","getAllFeatureFlags"],"sources":["C:/Users/user/Documents/app.v3/client/src/core/config/featureFlags.js"],"sourcesContent":["// client/src/core/config/featureFlags.js\r\n\r\nimport { openDB } from 'idb';\r\n\r\n// IndexedDB configuration\r\nconst DB_NAME = 'featureFlagsDB';\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = 'flags';\r\nconst FLAGS_KEY = 'currentFlags'; // Key to store the main flags object in IndexedDB\r\n\r\n// Default feature flags\r\nconst DEFAULT_FLAGS = {\r\n  firebaseDirectIntegration: false, // Default state: Firebase direct integration is off\r\n  analyticsDirectIntegration: false, // Default state: Analytics direct integration is off\r\n  documentsDirectIntegration: false, // Default state: Documents direct integration is off\r\n};\r\n\r\nlet featureFlags = {}; // In-memory cache of feature flags\r\nlet db = null; // IndexedDB database instance\r\n\r\n// Performance timing for feature flags\r\nconst performanceTimers = {};\r\n\r\n// Initialize IndexedDB\r\nconst initDatabase = async () => {\r\n  if (db) return db;\r\n  db = await openDB(DB_NAME, DB_VERSION, {\r\n    upgrade(db, oldVersion, newVersion, transaction) {\r\n      if (oldVersion < 1) {\r\n        // Create an object store for flags\r\n        const store = db.createObjectStore(STORE_NAME);\r\n        // You could add indexes here if needed, e.g., store.createIndex('by-name', 'name');\r\n      }\r\n    },\r\n  });\r\n  return db;\r\n};\r\n\r\n// Load feature flags from IndexedDB\r\nconst loadFeatureFlags = async () => {\r\n  try {\r\n    const db = await initDatabase();\r\n    const savedData = await db.get(STORE_NAME, FLAGS_KEY);\r\n\r\n    if (savedData && savedData.flags) {\r\n      featureFlags = { ...DEFAULT_FLAGS, ...savedData.flags };\r\n      console.log('Feature flags loaded from IndexedDB:', featureFlags);\r\n    } else {\r\n      featureFlags = { ...DEFAULT_FLAGS };\r\n      console.log('No feature flags found in IndexedDB, using defaults:', featureFlags);\r\n      // Save defaults to IndexedDB\r\n      await saveFeatureFlags();\r\n    }\r\n  } catch (error) {\r\n    console.error('Error loading feature flags from IndexedDB:', error);\r\n    featureFlags = { ...DEFAULT_FLAGS }; // Fallback to default if IndexedDB fails\r\n    console.log('Falling back to default feature flags due to IndexedDB error:', featureFlags);\r\n  }\r\n};\r\n\r\n// Save feature flags to IndexedDB\r\nconst saveFeatureFlags = async () => {\r\n  try {\r\n    const db = await initDatabase();\r\n    const timestamp = new Date().toISOString();\r\n    // In a real app, you might get the current user ID here\r\n    const auditInfo = { timestamp, userId: 'anonymous' }; // Placeholder user ID\r\n\r\n    const dataToSave = {\r\n      flags: featureFlags,\r\n      version: DB_VERSION, // Simple versioning based on DB version\r\n      audit: auditInfo,\r\n    };\r\n\r\n    await db.put(STORE_NAME, dataToSave, FLAGS_KEY);\r\n    console.log('Feature flags saved to IndexedDB:', featureFlags);\r\n\r\n    // Signal changes across tabs using localStorage (key change event)\r\n    // We don't store data here, just trigger the 'storage' event\r\n    localStorage.setItem(LOCAL_STORAGE_KEY_SIGNAL, Date.now().toString());\r\n\r\n  } catch (error) {\r\n    console.error('Error saving feature flags to IndexedDB:', error);\r\n  }\r\n};\r\n\r\n// Key for signaling changes across tabs via localStorage\r\nconst LOCAL_STORAGE_KEY_SIGNAL = 'featureFlagsChangeSignal';\r\n\r\n// Listen for changes signaled from other tabs\r\nwindow.addEventListener('storage', (event) => {\r\n  if (event.key === LOCAL_STORAGE_KEY_SIGNAL) {\r\n    console.log('Feature flags change signaled from another tab. Reloading...');\r\n    loadFeatureFlags(); // Reload flags from IndexedDB\r\n  }\r\n});\r\n\r\n// Load flags when the script is first executed\r\nloadFeatureFlags();\r\n\r\n/**\r\n * Tracks the usage of a feature flag.\r\n * @param {string} featureName - The name of the feature.\r\n */\r\nconst trackFeatureUsage = (featureName) => {\r\n  console.log(`[Feature Flag Usage] Checked: ${featureName}`);\r\n  // TODO: Integrate with actual analytics platform (e.g., Google Analytics, Sentry)\r\n  // Example: analytics.track('feature_flag_checked', { featureName, enabled: featureFlags[featureName] });\r\n};\r\n\r\n/**\r\n * Starts a performance timer for a feature flag.\r\n * @param {string} featureName - The name of the feature.\r\n */\r\nexport const startPerformanceTimer = (featureName) => {\r\n  if (typeof performance !== 'undefined' && performance.now) {\r\n    performanceTimers[featureName] = performance.now();\r\n    console.log(`[Feature Flag Performance] Timer started for: ${featureName}`);\r\n  } else {\r\n    console.warn('[Feature Flag Performance] Performance timing not available.');\r\n  }\r\n};\r\n\r\n/**\r\n * Stops a performance timer for a feature flag and logs the duration.\r\n * @param {string} featureName - The name of the feature.\r\n */\r\nexport const stopPerformanceTimer = (featureName) => {\r\n  if (typeof performance !== 'undefined' && performance.now && performanceTimers[featureName]) {\r\n    const duration = performance.now() - performanceTimers[featureName];\r\n    console.log(`[Feature Flag Performance] Timer stopped for: ${featureName}, Duration: ${duration.toFixed(2)}ms`);\r\n    // TODO: Send duration to analytics/performance monitoring platform\r\n    // Example: analytics.track('feature_flag_performance', { featureName, duration });\r\n    delete performanceTimers[featureName]; // Clean up the timer\r\n  } else if (typeof performance !== 'undefined' && performance.now) {\r\n     console.warn(`[Feature Flag Performance] Timer not found for: ${featureName}`);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Checks if a specific feature is enabled.\r\n * @param {string} featureName - The name of the feature.\r\n * @returns {boolean} - True if the feature is enabled, false otherwise.\r\n */\r\nexport const isFeatureEnabled = (featureName) => {\r\n  // Track usage whenever a flag is checked\r\n  trackFeatureUsage(featureName);\r\n  // Use the in-memory cache\r\n  return !!featureFlags[featureName];\r\n};\r\n\r\n/**\r\n * Enables a specific feature.\r\n * @param {string} featureName - The name of the feature.\r\n */\r\nexport const enableFeature = async (featureName) => {\r\n  if (featureFlags[featureName] === true) {\r\n    console.log(`Feature \"${featureName}\" is already enabled.`);\r\n    return;\r\n  }\r\n  featureFlags = { ...featureFlags, [featureName]: true };\r\n  console.log(`Feature \"${featureName}\" enabled.`);\r\n  await saveFeatureFlags();\r\n};\r\n\r\n/**\r\n * Disables a specific feature.\r\n * @param {string} featureName - The name of the feature.\r\n */\r\nexport const disableFeature = async (featureName) => {\r\n  if (featureFlags[featureName] === false) {\r\n    console.log(`Feature \"${featureName}\" is already disabled.`);\r\n    return;\r\n  }\r\n  featureFlags = { ...featureFlags, [featureName]: false };\r\n  console.log(`Feature \"${featureName}\" disabled.`);\r\n  await saveFeatureFlags();\r\n};\r\n\r\n/**\r\n * Gets the current state of all feature flags.\r\n * @returns {object} - An object containing all feature flags and their states.\r\n */\r\nexport const getAllFeatureFlags = () => {\r\n  // Return a copy of the in-memory cache\r\n  return { ...featureFlags };\r\n};\r\n\r\n// Add comments about purpose and design\r\n// Purpose: To provide a centralized system for controlling the visibility and behavior of features during development and rollout, with robust persistence, versioning, auditing, and basic analytics/performance tracking using IndexedDB and console logging.\r\n// Design: Uses IndexedDB for persistent storage of feature flag states, version information, and audit logs. Maintains an in-memory cache (`featureFlags`) for quick access. Changes are synchronized across tabs using a localStorage signaling mechanism. Provides utility functions for checking, enabling, and disabling features, which update both the in-memory cache and IndexedDB. Includes basic console logging for feature usage tracking and performance timing, with placeholders for integration with dedicated analytics platforms.\r\n// How to add new feature toggles: Add a new key-value pair to the `DEFAULT_FLAGS` object. The system will automatically handle loading, saving, and persistence for new flags added to the defaults. Add a description in `FeatureToggles.js`.\r\n// Persistence: Feature flags are stored in an IndexedDB database named 'featureFlagsDB' in an object store named 'flags'. The main flags object is stored under the key 'currentFlags'.\r\n// Versioning: A simple version number (`DB_VERSION`) is stored along with the flags. More complex versioning or migration logic can be added in the `upgrade` function of `openDB`.\r\n// Auditing: Each save operation records a timestamp and a placeholder user ID (should be replaced with actual user ID in an authenticated context) in the audit field.\r\n// Synchronization: A change to feature flags in one tab triggers a `storage` event in other tabs by writing a timestamp to a specific localStorage key (`featureFlagsChangeSignal`). The event listener in other tabs then reloads the flags from IndexedDB, ensuring all tabs are eventually consistent.\r\n// Analytics: Basic usage tracking is implemented by logging to the console whenever `isFeatureEnabled` is called. Performance timing can be measured for specific code blocks using `startPerformanceTimer` and `stopPerformanceTimer`, with results logged to the console. These should be integrated with a proper analytics/performance monitoring platform for production use.\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
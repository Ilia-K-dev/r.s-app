{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useState, useEffect, useCallback } from 'react';\nimport { useAuth } from \"../../../features/auth/hooks/useAuth\";\nimport { categoriesApi } from \"../../../features/categories/services/categories\";\nimport { getCache, setCache, invalidateCache } from \"../../../shared/utils/cache\";\nimport logger from \"../../../shared/utils/logger\";\nexport var useCategories = function useCategories() {\n  var _useState = useState([]),\n    _useState2 = _slicedToArray(_useState, 2),\n    categories = _useState2[0],\n    setCategories = _useState2[1];\n  var _useState3 = useState(true),\n    _useState4 = _slicedToArray(_useState3, 2),\n    loading = _useState4[0],\n    setLoading = _useState4[1];\n  var _useState5 = useState(null),\n    _useState6 = _slicedToArray(_useState5, 2),\n    error = _useState6[0],\n    setError = _useState6[1];\n  var _useAuth = useAuth(),\n    user = _useAuth.user;\n  var fetchCategories = useCallback(_asyncToGenerator(function* () {\n    try {\n      setLoading(true);\n      setError(null);\n      if (!user) {\n        setCategories([]);\n        setLoading(false);\n        return;\n      }\n      var cacheKey = `categories-${user.uid}`;\n      var cachedData = getCache(cacheKey);\n      if (cachedData) {\n        setCategories(cachedData);\n        setLoading(false);\n        logger.info(`Fetched categories from cache for user ${user.uid}`);\n        return;\n      }\n      logger.info(`Fetching categories from API for user ${user.uid}`);\n      var data = yield categoriesApi.getCategories(user.uid);\n      setCategories(data);\n      setError(null);\n      setCache(cacheKey, data, 5 * 60 * 1000);\n    } catch (err) {\n      setError(err.message);\n      logger.error(`Error fetching categories for user ${user.uid}: ${err.message}`);\n    } finally {\n      setLoading(false);\n    }\n  }), [user]);\n  var addCategory = useCallback(function () {\n    var _ref2 = _asyncToGenerator(function* (categoryData) {\n      try {\n        if (!user) throw new Error('User not authenticated');\n        var newCategory = yield categoriesApi.addCategory(user.uid, categoryData);\n        setCategories(function (prev) {\n          return [].concat(_toConsumableArray(prev), [newCategory]);\n        });\n        invalidateCache(`categories-${user.uid}`);\n        return newCategory;\n      } catch (err) {\n        logger.error(`Error adding category for user ${user.uid}: ${err.message}`);\n        throw new Error('Failed to add category');\n      }\n    });\n    return function (_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), [user]);\n  var updateCategory = useCallback(function () {\n    var _ref3 = _asyncToGenerator(function* (id, categoryData) {\n      try {\n        if (!user) throw new Error('User not authenticated');\n        yield categoriesApi.updateCategory(id, categoryData);\n        setCategories(function (prev) {\n          return prev.map(function (cat) {\n            return cat.id === id ? _objectSpread(_objectSpread({}, cat), categoryData) : cat;\n          });\n        });\n        invalidateCache(`categories-${user.uid}`);\n      } catch (err) {\n        logger.error(`Error updating category ${id} for user ${user.uid}: ${err.message}`);\n        throw new Error('Failed to update category');\n      }\n    });\n    return function (_x2, _x3) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [user]);\n  var deleteCategory = useCallback(function () {\n    var _ref4 = _asyncToGenerator(function* (id) {\n      try {\n        if (!user) throw new Error('User not authenticated');\n        yield categoriesApi.deleteCategory(id);\n        setCategories(function (prev) {\n          return prev.filter(function (cat) {\n            return cat.id !== id;\n          });\n        });\n        invalidateCache(`categories-${user.uid}`);\n      } catch (err) {\n        logger.error(`Error deleting category ${id} for user ${user.uid}: ${err.message}`);\n        throw new Error('Failed to delete category');\n      }\n    });\n    return function (_x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }(), [user]);\n  useEffect(function () {\n    if (user) {\n      fetchCategories();\n    } else {\n      setCategories([]);\n    }\n  }, [user, fetchCategories]);\n  return {\n    categories: categories,\n    loading: loading,\n    error: error,\n    fetchCategories: fetchCategories,\n    addCategory: addCategory,\n    updateCategory: updateCategory,\n    deleteCategory: deleteCategory\n  };\n};","map":{"version":3,"names":["useState","useEffect","useCallback","useAuth","categoriesApi","getCache","setCache","invalidateCache","logger","useCategories","_useState","_useState2","_slicedToArray","categories","setCategories","_useState3","_useState4","loading","setLoading","_useState5","_useState6","error","setError","_useAuth","user","fetchCategories","_asyncToGenerator","cacheKey","uid","cachedData","info","data","getCategories","err","message","addCategory","_ref2","categoryData","Error","newCategory","prev","concat","_toConsumableArray","_x","apply","arguments","updateCategory","_ref3","id","map","cat","_objectSpread","_x2","_x3","deleteCategory","_ref4","filter","_x4"],"sources":["C:/Users/user/Documents/app.v3/client/src/features/categories/hooks/useCategories.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react'; // Add useCallback\r\nimport { useAuth } from '../../../features/auth/hooks/useAuth';\r\nimport { categoriesApi } from '../../../features/categories/services/categories'; // Assuming categoriesApi exists\r\nimport { getCache, setCache, invalidateCache } from '../../../shared/utils/cache'; // Import cache utility\r\nimport logger from '../../../shared/utils/logger'; // Assuming a shared logger utility\r\n\r\n/**\r\n * @typedef {object} Category\r\n * @property {string} id - The category ID.\r\n * @property {string} userId - The ID of the user who owns the category.\r\n * @property {string} name - The category name.\r\n * @property {number} [budget] - Optional budget for the category.\r\n * @property {string} [color] - Optional color for the category (hex code).\r\n * // Add other relevant category properties here\r\n */\r\n\r\n/**\r\n * @typedef {object} UseCategoriesReturn\r\n * @property {Category[]} categories - Array of fetched categories.\r\n * @property {boolean} loading - Loading state.\r\n * @property {string|null} error - Error message if fetching/mutating failed.\r\n * @property {function(): Promise<void>} fetchCategories - Function to fetch categories.\r\n * @property {function(object): Promise<object>} addCategory - Function to add a new category.\r\n * @property {function(string, object): Promise<void>} updateCategory - Function to update an existing category.\r\n * @property {function(string): Promise<void>} deleteCategory - Function to delete a category.\r\n */\r\n\r\n/**\r\n * @desc Custom hook for fetching, adding, updating, and deleting user categories.\r\n * Manages loading, error, and categories state. Uses client-side caching.\r\n * @returns {UseCategoriesReturn} - Object containing categories data, state, and functions.\r\n */\r\nexport const useCategories = () => {\r\n  const [categories, setCategories] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const { user } = useAuth();\r\n\r\n  /**\r\n   * @desc Fetches categories from the backend API or cache.\r\n   * Updates categories state.\r\n   * @returns {Promise<void>}\r\n   */\r\n  const fetchCategories = useCallback(async () => { // Wrap in useCallback\r\n    try {\r\n      setLoading(true);\r\n      setError(null); // Reset error state\r\n\r\n      if (!user) {\r\n        setCategories([]); // Clear categories if user is not authenticated\r\n        setLoading(false);\r\n        return;\r\n      }\r\n\r\n      const cacheKey = `categories-${user.uid}`;\r\n      const cachedData = getCache(cacheKey);\r\n\r\n      if (cachedData) {\r\n        setCategories(cachedData);\r\n        setLoading(false);\r\n        logger.info(`Fetched categories from cache for user ${user.uid}`); // Add logging\r\n        return;\r\n      }\r\n\r\n      logger.info(`Fetching categories from API for user ${user.uid}`); // Add logging\r\n      // Assuming categoriesApi.getCategories exists and fetches categories for a user\r\n      const data = await categoriesApi.getCategories(user.uid);\r\n      setCategories(data);\r\n      setError(null);\r\n      setCache(cacheKey, data, 5 * 60 * 1000); // Cache for 5 minutes\r\n\r\n    } catch (err) {\r\n      setError(err.message);\r\n      logger.error(`Error fetching categories for user ${user.uid}: ${err.message}`); // Add logging\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [user]); // Dependency on user\r\n\r\n  /**\r\n   * @desc Adds a new category via the backend API.\r\n   * Adds the new category to the local state and invalidates the cache.\r\n   * @param {object} categoryData - The data for the new category.\r\n   * @returns {Promise<object>} - A promise that resolves with the created category data.\r\n   * @throws {Error} - Throws an error if the API request fails.\r\n   */\r\n  const addCategory = useCallback(async categoryData => { // Wrap in useCallback\r\n    try {\r\n      if (!user) throw new Error('User not authenticated'); // Add auth check\r\n      // Assuming categoriesApi.addCategory exists and adds a category for a user\r\n      const newCategory = await categoriesApi.addCategory(user.uid, categoryData);\r\n      setCategories(prev => [...prev, newCategory]);\r\n      invalidateCache(`categories-${user.uid}`); // Invalidate cache\r\n      return newCategory;\r\n    } catch (err) {\r\n      logger.error(`Error adding category for user ${user.uid}: ${err.message}`); // Add logging\r\n      throw new Error('Failed to add category');\r\n    }\r\n  }, [user]); // Dependency on user\r\n\r\n  /**\r\n   * @desc Updates an existing category via the backend API.\r\n   * Updates the category in the local state and invalidates the cache.\r\n   * @param {string} id - The ID of the category to update.\r\n   * @param {object} categoryData - The data to update the category with.\r\n   * @returns {Promise<void>} - A promise that resolves when the update is complete.\r\n   * @throws {Error} - Throws an error if the API request fails.\r\n   */\r\n  const updateCategory = useCallback(async (id, categoryData) => { // Wrap in useCallback\r\n    try {\r\n      if (!user) throw new Error('User not authenticated'); // Add auth check\r\n      // Assuming categoriesApi.updateCategory exists and updates a category\r\n      await categoriesApi.updateCategory(id, categoryData);\r\n      setCategories(prev => prev.map(cat => (cat.id === id ? { ...cat, ...categoryData } : cat)));\r\n      invalidateCache(`categories-${user.uid}`); // Invalidate cache\r\n    } catch (err) {\r\n      logger.error(`Error updating category ${id} for user ${user.uid}: ${err.message}`); // Add logging\r\n      throw new Error('Failed to update category');\r\n    }\r\n  }, [user]); // Dependency on user\r\n\r\n  /**\r\n   * @desc Deletes a category via the backend API.\r\n   * Removes the category from the local state and invalidates the cache.\r\n   * @param {string} id - The ID of the category to delete.\r\n   * @returns {Promise<void>} - A promise that resolves when the deletion is complete.\r\n   * @throws {Error} - Throws an error if the API request fails.\r\n   */\r\n  const deleteCategory = useCallback(async id => { // Wrap in useCallback\r\n    try {\r\n      if (!user) throw new Error('User not authenticated'); // Add auth check\r\n      // Assuming categoriesApi.deleteCategory exists and deletes a category\r\n      await categoriesApi.deleteCategory(id);\r\n      setCategories(prev => prev.filter(cat => cat.id !== id));\r\n      invalidateCache(`categories-${user.uid}`); // Invalidate cache\r\n    } catch (err) {\r\n      logger.error(`Error deleting category ${id} for user ${user.uid}: ${err.message}`); // Add logging\r\n      throw new Error('Failed to delete category');\r\n    }\r\n  }, [user]); // Dependency on user\r\n\r\n  // Fetch categories when user changes\r\n  useEffect(() => {\r\n    if (user) {\r\n      fetchCategories();\r\n    } else {\r\n      setCategories([]); // Clear categories if user logs out\r\n    }\r\n  }, [user, fetchCategories]); // Dependency on user and fetchCategories\r\n\r\n  return {\r\n    categories,\r\n    loading,\r\n    error,\r\n    fetchCategories,\r\n    addCategory,\r\n    updateCategory,\r\n    deleteCategory,\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
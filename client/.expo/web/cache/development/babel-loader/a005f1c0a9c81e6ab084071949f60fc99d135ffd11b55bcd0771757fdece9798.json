{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _toArray = require(\"@babel/runtime/helpers/toArray\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _require = require(\"./util/hints\"),\n  stringHints = _require.stringHints,\n  numberHints = _require.numberHints;\nvar SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\nfunction filterMax(array, fn) {\n  var evaluatedMax = array.reduce(function (max, item) {\n    return Math.max(max, fn(item));\n  }, 0);\n  return array.filter(function (item) {\n    return fn(item) === evaluatedMax;\n  });\n}\nfunction filterChildren(children) {\n  var newChildren = children;\n  newChildren = filterMax(newChildren, function (error) {\n    return error.dataPath ? error.dataPath.length : 0;\n  });\n  newChildren = filterMax(newChildren, function (error) {\n    return SPECIFICITY[error.keyword] || 2;\n  });\n  return newChildren;\n}\nfunction findAllChildren(children, schemaPaths) {\n  var i = children.length - 1;\n  var predicate = function predicate(schemaPath) {\n    return children[i].schemaPath.indexOf(schemaPath) !== 0;\n  };\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === 'anyOf' || children[i].keyword === 'oneOf') {\n      var refs = extractRefs(children[i]);\n      var childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n  return i + 1;\n}\nfunction extractRefs(error) {\n  var schema = error.schema;\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n  return schema.map(function (_ref) {\n    var $ref = _ref.$ref;\n    return $ref;\n  }).filter(function (s) {\n    return s;\n  });\n}\nfunction groupChildrenByFirstChild(children) {\n  var result = [];\n  var i = children.length - 1;\n  while (i > 0) {\n    var child = children[i];\n    if (child.keyword === 'anyOf' || child.keyword === 'oneOf') {\n      var refs = extractRefs(child);\n      var childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n    i -= 1;\n  }\n  if (i === 0) {\n    result.push(children[i]);\n  }\n  return result.reverse();\n}\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n  return schema;\n}\nfunction canApplyNot(schema) {\n  var typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\nfunction isObject(maybeObj) {\n  return typeof maybeObj === 'object' && maybeObj !== null;\n}\nfunction likeNumber(schema) {\n  return schema.type === 'number' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\nfunction likeInteger(schema) {\n  return schema.type === 'integer' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\nfunction likeString(schema) {\n  return schema.type === 'string' || typeof schema.minLength !== 'undefined' || typeof schema.maxLength !== 'undefined' || typeof schema.pattern !== 'undefined' || typeof schema.format !== 'undefined' || typeof schema.formatMinimum !== 'undefined' || typeof schema.formatMaximum !== 'undefined';\n}\nfunction likeBoolean(schema) {\n  return schema.type === 'boolean';\n}\nfunction likeArray(schema) {\n  return schema.type === 'array' || typeof schema.minItems === 'number' || typeof schema.maxItems === 'number' || typeof schema.uniqueItems !== 'undefined' || typeof schema.items !== 'undefined' || typeof schema.additionalItems !== 'undefined' || typeof schema.contains !== 'undefined';\n}\nfunction likeObject(schema) {\n  return schema.type === 'object' || typeof schema.minProperties !== 'undefined' || typeof schema.maxProperties !== 'undefined' || typeof schema.required !== 'undefined' || typeof schema.properties !== 'undefined' || typeof schema.patternProperties !== 'undefined' || typeof schema.additionalProperties !== 'undefined' || typeof schema.dependencies !== 'undefined' || typeof schema.propertyNames !== 'undefined' || typeof schema.patternRequired !== 'undefined';\n}\nfunction likeNull(schema) {\n  return schema.type === 'null';\n}\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return 'an';\n  }\n  return 'a';\n}\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return '';\n  }\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return ' | should be any non-number';\n    }\n    if (likeString(schema)) {\n      return ' | should be any non-string';\n    }\n    if (likeArray(schema)) {\n      return ' | should be any non-array';\n    }\n    if (likeObject(schema)) {\n      return ' | should be any non-object';\n    }\n  }\n  return '';\n}\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(', ')})` : '';\n}\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    return numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    return stringHints(schema, logic);\n  }\n  return [];\n}\nvar ValidationError = function (_Error) {\n  function ValidationError(errors, schema) {\n    var _this;\n    var configuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, ValidationError);\n    _this = _callSuper(this, ValidationError);\n    _this.name = 'ValidationError';\n    _this.errors = errors;\n    _this.schema = schema;\n    var headerNameFromSchema;\n    var baseDataPathFromSchema;\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      var splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          var _splittedTitleFromSch = _slicedToArray(splittedTitleFromSchema, 2);\n          headerNameFromSchema = _splittedTitleFromSch[1];\n        }\n        if (!configuration.baseDataPath) {\n          var _splittedTitleFromSch2 = _slicedToArray(splittedTitleFromSchema, 3);\n          baseDataPathFromSchema = _splittedTitleFromSch2[2];\n        }\n      }\n    }\n    _this.headerName = configuration.name || headerNameFromSchema || 'Object';\n    _this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || 'configuration';\n    _this.postFormatter = configuration.postFormatter || null;\n    var header = `Invalid ${_this.baseDataPath} object. ${_this.headerName} has been initialized using ${getArticle(_this.baseDataPath)} ${_this.baseDataPath} object that does not match the API schema.\\n`;\n    _this.message = `${header}${_this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(_this, _this.constructor);\n    return _this;\n  }\n  _inherits(ValidationError, _Error);\n  return _createClass(ValidationError, [{\n    key: \"getSchemaPart\",\n    value: function getSchemaPart(path) {\n      var newPath = path.split('/');\n      var schemaPart = this.schema;\n      for (var i = 1; i < newPath.length; i++) {\n        var inner = schemaPart[newPath[i]];\n        if (!inner) {\n          break;\n        }\n        schemaPart = inner;\n      }\n      return schemaPart;\n    }\n  }, {\n    key: \"formatSchema\",\n    value: function formatSchema(schema) {\n      var _this2 = this;\n      var logic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var prevSchemas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var newLogic = logic;\n      var formatInnerSchema = function formatInnerSchema(innerSchema, addSelf) {\n        if (!addSelf) {\n          return _this2.formatSchema(innerSchema, newLogic, prevSchemas);\n        }\n        if (prevSchemas.includes(innerSchema)) {\n          return '(recursive)';\n        }\n        return _this2.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n      };\n      if (hasNotInSchema(schema) && !likeObject(schema)) {\n        if (canApplyNot(schema.not)) {\n          newLogic = !logic;\n          return formatInnerSchema(schema.not);\n        }\n        var needApplyLogicHere = !schema.not.not;\n        var prefix = logic ? '' : 'non ';\n        newLogic = !logic;\n        return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n      }\n      if (schema.instanceof) {\n        var value = schema.instanceof;\n        var values = !Array.isArray(value) ? [value] : value;\n        return values.map(function (item) {\n          return item === 'Function' ? 'function' : item;\n        }).join(' | ');\n      }\n      if (schema.enum) {\n        return schema.enum.map(function (item) {\n          return JSON.stringify(item);\n        }).join(' | ');\n      }\n      if (typeof schema.const !== 'undefined') {\n        return JSON.stringify(schema.const);\n      }\n      if (schema.oneOf) {\n        return schema.oneOf.map(function (item) {\n          return formatInnerSchema(item, true);\n        }).join(' | ');\n      }\n      if (schema.anyOf) {\n        return schema.anyOf.map(function (item) {\n          return formatInnerSchema(item, true);\n        }).join(' | ');\n      }\n      if (schema.allOf) {\n        return schema.allOf.map(function (item) {\n          return formatInnerSchema(item, true);\n        }).join(' & ');\n      }\n      if (schema.if) {\n        var ifValue = schema.if,\n          thenValue = schema.then,\n          elseValue = schema.else;\n        return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : ''}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : ''}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : ''}`;\n      }\n      if (schema.$ref) {\n        return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n      }\n      if (likeNumber(schema) || likeInteger(schema)) {\n        var _getHints = getHints(schema, logic),\n          _getHints2 = _toArray(_getHints),\n          type = _getHints2[0],\n          hints = _getHints2.slice(1);\n        var str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ''}`;\n        return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n      }\n      if (likeString(schema)) {\n        var _getHints3 = getHints(schema, logic),\n          _getHints4 = _toArray(_getHints3),\n          _type = _getHints4[0],\n          _hints = _getHints4.slice(1);\n        var _str = `${_type}${_hints.length > 0 ? ` ${formatHints(_hints)}` : ''}`;\n        return logic ? _str : _str === 'string' ? 'non-string' : `non-string | ${_str}`;\n      }\n      if (likeBoolean(schema)) {\n        return `${logic ? '' : 'non-'}boolean`;\n      }\n      if (likeArray(schema)) {\n        newLogic = true;\n        var _hints2 = [];\n        if (typeof schema.minItems === 'number') {\n          _hints2.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? 's' : ''}`);\n        }\n        if (typeof schema.maxItems === 'number') {\n          _hints2.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? 's' : ''}`);\n        }\n        if (schema.uniqueItems) {\n          _hints2.push('should not have duplicate items');\n        }\n        var hasAdditionalItems = typeof schema.additionalItems === 'undefined' || Boolean(schema.additionalItems);\n        var items = '';\n        if (schema.items) {\n          if (Array.isArray(schema.items) && schema.items.length > 0) {\n            items = `${schema.items.map(function (item) {\n              return formatInnerSchema(item);\n            }).join(', ')}`;\n            if (hasAdditionalItems) {\n              if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n                _hints2.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n              }\n            }\n          } else if (schema.items && Object.keys(schema.items).length > 0) {\n            items = `${formatInnerSchema(schema.items)}`;\n          } else {\n            items = 'any';\n          }\n        } else {\n          items = 'any';\n        }\n        if (schema.contains && Object.keys(schema.contains).length > 0) {\n          _hints2.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n        }\n        return `[${items}${hasAdditionalItems ? ', ...' : ''}]${_hints2.length > 0 ? ` (${_hints2.join(', ')})` : ''}`;\n      }\n      if (likeObject(schema)) {\n        newLogic = true;\n        var _hints3 = [];\n        if (typeof schema.minProperties === 'number') {\n          _hints3.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? 'properties' : 'property'}`);\n        }\n        if (typeof schema.maxProperties === 'number') {\n          _hints3.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? 'properties' : 'property'}`);\n        }\n        if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n          var patternProperties = Object.keys(schema.patternProperties);\n          _hints3.push(`additional property names should match pattern${patternProperties.length > 1 ? 's' : ''} ${patternProperties.map(function (pattern) {\n            return JSON.stringify(pattern);\n          }).join(' | ')}`);\n        }\n        var properties = schema.properties ? Object.keys(schema.properties) : [];\n        var required = schema.required ? schema.required : [];\n        var allProperties = _toConsumableArray(new Set([].concat(required).concat(properties)));\n        var objectStructure = allProperties.map(function (property) {\n          var isRequired = required.includes(property);\n          return `${property}${isRequired ? '' : '?'}`;\n        }).concat(typeof schema.additionalProperties === 'undefined' || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : ['…'] : []).join(', ');\n        var dependencies = schema.dependencies,\n          propertyNames = schema.propertyNames,\n          patternRequired = schema.patternRequired;\n        if (dependencies) {\n          Object.keys(dependencies).forEach(function (dependencyName) {\n            var dependency = dependencies[dependencyName];\n            if (Array.isArray(dependency)) {\n              _hints3.push(`should have ${dependency.length > 1 ? 'properties' : 'property'} ${dependency.map(function (dep) {\n                return `'${dep}'`;\n              }).join(', ')} when property '${dependencyName}' is present`);\n            } else {\n              _hints3.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n            }\n          });\n        }\n        if (propertyNames && Object.keys(propertyNames).length > 0) {\n          _hints3.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n        }\n        if (patternRequired && patternRequired.length > 0) {\n          _hints3.push(`should have property matching pattern ${patternRequired.map(function (item) {\n            return JSON.stringify(item);\n          })}`);\n        }\n        return `object {${objectStructure ? ` ${objectStructure} ` : ''}}${_hints3.length > 0 ? ` (${_hints3.join(', ')})` : ''}`;\n      }\n      if (likeNull(schema)) {\n        return `${logic ? '' : 'non-'}null`;\n      }\n      if (Array.isArray(schema.type)) {\n        return `${schema.type.join(' | ')}`;\n      }\n      return JSON.stringify(schema, null, 2);\n    }\n  }, {\n    key: \"getSchemaPartText\",\n    value: function getSchemaPartText(schemaPart, additionalPath) {\n      var needDot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var logic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      if (!schemaPart) {\n        return '';\n      }\n      if (Array.isArray(additionalPath)) {\n        for (var i = 0; i < additionalPath.length; i++) {\n          var inner = schemaPart[additionalPath[i]];\n          if (inner) {\n            schemaPart = inner;\n          } else {\n            break;\n          }\n        }\n      }\n      while (schemaPart.$ref) {\n        schemaPart = this.getSchemaPart(schemaPart.$ref);\n      }\n      var schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? '.' : ''}`;\n      if (schemaPart.description) {\n        schemaText += `\\n-> ${schemaPart.description}`;\n      }\n      return schemaText;\n    }\n  }, {\n    key: \"getSchemaPartDescription\",\n    value: function getSchemaPartDescription(schemaPart) {\n      if (!schemaPart) {\n        return '';\n      }\n      while (schemaPart.$ref) {\n        schemaPart = this.getSchemaPart(schemaPart.$ref);\n      }\n      if (schemaPart.description) {\n        return `\\n-> ${schemaPart.description}`;\n      }\n      return '';\n    }\n  }, {\n    key: \"formatValidationError\",\n    value: function formatValidationError(error) {\n      var _this3 = this;\n      var keyword = error.keyword,\n        errorDataPath = error.dataPath;\n      var dataPath = `${this.baseDataPath}${errorDataPath}`;\n      switch (keyword) {\n        case 'type':\n          {\n            var parentSchema = error.parentSchema,\n              params = error.params;\n            switch (params.type) {\n              case 'number':\n                return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n              case 'integer':\n                return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n              case 'string':\n                return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n              case 'boolean':\n                return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n              case 'array':\n                return `${dataPath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n              case 'object':\n                return `${dataPath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n              case 'null':\n                return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n              default:\n                return `${dataPath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n            }\n          }\n        case 'instanceof':\n          {\n            var _parentSchema = error.parentSchema;\n            return `${dataPath} should be an instance of ${this.getSchemaPartText(_parentSchema, false, true)}`;\n          }\n        case 'pattern':\n          {\n            var _params = error.params,\n              _parentSchema2 = error.parentSchema;\n            var pattern = _params.pattern;\n            return `${dataPath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(_parentSchema2)}.${this.getSchemaPartDescription(_parentSchema2)}`;\n          }\n        case 'format':\n          {\n            var _params2 = error.params,\n              _parentSchema3 = error.parentSchema;\n            var format = _params2.format;\n            return `${dataPath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(_parentSchema3)}.${this.getSchemaPartDescription(_parentSchema3)}`;\n          }\n        case 'formatMinimum':\n        case 'formatMaximum':\n          {\n            var _params3 = error.params,\n              _parentSchema4 = error.parentSchema;\n            var comparison = _params3.comparison,\n              limit = _params3.limit;\n            return `${dataPath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(_parentSchema4)}.${this.getSchemaPartDescription(_parentSchema4)}`;\n          }\n        case 'minimum':\n        case 'maximum':\n        case 'exclusiveMinimum':\n        case 'exclusiveMaximum':\n          {\n            var _parentSchema5 = error.parentSchema,\n              _params4 = error.params;\n            var _comparison = _params4.comparison,\n              _limit = _params4.limit;\n            var _getHints5 = getHints(_parentSchema5, true),\n              _getHints6 = _toArray(_getHints5),\n              hints = _getHints6.slice(1);\n            if (hints.length === 0) {\n              hints.push(`should be ${_comparison} ${_limit}`);\n            }\n            return `${dataPath} ${hints.join(' ')}${getSchemaNonTypes(_parentSchema5)}.${this.getSchemaPartDescription(_parentSchema5)}`;\n          }\n        case 'multipleOf':\n          {\n            var _params5 = error.params,\n              _parentSchema6 = error.parentSchema;\n            var multipleOf = _params5.multipleOf;\n            return `${dataPath} should be multiple of ${multipleOf}${getSchemaNonTypes(_parentSchema6)}.${this.getSchemaPartDescription(_parentSchema6)}`;\n          }\n        case 'patternRequired':\n          {\n            var _params6 = error.params,\n              _parentSchema7 = error.parentSchema;\n            var missingPattern = _params6.missingPattern;\n            return `${dataPath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(_parentSchema7)}.${this.getSchemaPartDescription(_parentSchema7)}`;\n          }\n        case 'minLength':\n          {\n            var _params7 = error.params,\n              _parentSchema8 = error.parentSchema;\n            var _limit2 = _params7.limit;\n            if (_limit2 === 1) {\n              return `${dataPath} should be an non-empty string${getSchemaNonTypes(_parentSchema8)}.${this.getSchemaPartDescription(_parentSchema8)}`;\n            }\n            var length = _limit2 - 1;\n            return `${dataPath} should be longer than ${length} character${length > 1 ? 's' : ''}${getSchemaNonTypes(_parentSchema8)}.${this.getSchemaPartDescription(_parentSchema8)}`;\n          }\n        case 'minItems':\n          {\n            var _params8 = error.params,\n              _parentSchema9 = error.parentSchema;\n            var _limit3 = _params8.limit;\n            if (_limit3 === 1) {\n              return `${dataPath} should be an non-empty array${getSchemaNonTypes(_parentSchema9)}.${this.getSchemaPartDescription(_parentSchema9)}`;\n            }\n            return `${dataPath} should not have fewer than ${_limit3} items${getSchemaNonTypes(_parentSchema9)}.${this.getSchemaPartDescription(_parentSchema9)}`;\n          }\n        case 'minProperties':\n          {\n            var _params9 = error.params,\n              _parentSchema0 = error.parentSchema;\n            var _limit4 = _params9.limit;\n            if (_limit4 === 1) {\n              return `${dataPath} should be an non-empty object${getSchemaNonTypes(_parentSchema0)}.${this.getSchemaPartDescription(_parentSchema0)}`;\n            }\n            return `${dataPath} should not have fewer than ${_limit4} properties${getSchemaNonTypes(_parentSchema0)}.${this.getSchemaPartDescription(_parentSchema0)}`;\n          }\n        case 'maxLength':\n          {\n            var _params0 = error.params,\n              _parentSchema1 = error.parentSchema;\n            var _limit5 = _params0.limit;\n            var max = _limit5 + 1;\n            return `${dataPath} should be shorter than ${max} character${max > 1 ? 's' : ''}${getSchemaNonTypes(_parentSchema1)}.${this.getSchemaPartDescription(_parentSchema1)}`;\n          }\n        case 'maxItems':\n          {\n            var _params1 = error.params,\n              _parentSchema10 = error.parentSchema;\n            var _limit6 = _params1.limit;\n            return `${dataPath} should not have more than ${_limit6} items${getSchemaNonTypes(_parentSchema10)}.${this.getSchemaPartDescription(_parentSchema10)}`;\n          }\n        case 'maxProperties':\n          {\n            var _params10 = error.params,\n              _parentSchema11 = error.parentSchema;\n            var _limit7 = _params10.limit;\n            return `${dataPath} should not have more than ${_limit7} properties${getSchemaNonTypes(_parentSchema11)}.${this.getSchemaPartDescription(_parentSchema11)}`;\n          }\n        case 'uniqueItems':\n          {\n            var _params11 = error.params,\n              _parentSchema12 = error.parentSchema;\n            var i = _params11.i;\n            return `${dataPath} should not contain the item '${error.data[i]}' twice${getSchemaNonTypes(_parentSchema12)}.${this.getSchemaPartDescription(_parentSchema12)}`;\n          }\n        case 'additionalItems':\n          {\n            var _params12 = error.params,\n              _parentSchema13 = error.parentSchema;\n            var _limit8 = _params12.limit;\n            return `${dataPath} should not have more than ${_limit8} items${getSchemaNonTypes(_parentSchema13)}. These items are valid:\\n${this.getSchemaPartText(_parentSchema13)}`;\n          }\n        case 'contains':\n          {\n            var _parentSchema14 = error.parentSchema;\n            return `${dataPath} should contains at least one ${this.getSchemaPartText(_parentSchema14, ['contains'])} item${getSchemaNonTypes(_parentSchema14)}.`;\n          }\n        case 'required':\n          {\n            var _parentSchema15 = error.parentSchema,\n              _params13 = error.params;\n            var missingProperty = _params13.missingProperty.replace(/^\\./, '');\n            var hasProperty = _parentSchema15 && Boolean(_parentSchema15.properties && _parentSchema15.properties[missingProperty]);\n            return `${dataPath} misses the property '${missingProperty}'${getSchemaNonTypes(_parentSchema15)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(_parentSchema15, ['properties', missingProperty])}` : this.getSchemaPartDescription(_parentSchema15)}`;\n          }\n        case 'additionalProperties':\n          {\n            var _params14 = error.params,\n              _parentSchema16 = error.parentSchema;\n            var additionalProperty = _params14.additionalProperty;\n            return `${dataPath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(_parentSchema16)}. These properties are valid:\\n${this.getSchemaPartText(_parentSchema16)}`;\n          }\n        case 'dependencies':\n          {\n            var _params15 = error.params,\n              _parentSchema17 = error.parentSchema;\n            var property = _params15.property,\n              deps = _params15.deps;\n            var dependencies = deps.split(',').map(function (dep) {\n              return `'${dep.trim()}'`;\n            }).join(', ');\n            return `${dataPath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(_parentSchema17)}.${this.getSchemaPartDescription(_parentSchema17)}`;\n          }\n        case 'propertyNames':\n          {\n            var _params16 = error.params,\n              _parentSchema18 = error.parentSchema,\n              schema = error.schema;\n            var propertyName = _params16.propertyName;\n            return `${dataPath} property name '${propertyName}' is invalid${getSchemaNonTypes(_parentSchema18)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(_parentSchema18)}`;\n          }\n        case 'enum':\n          {\n            var _parentSchema19 = error.parentSchema;\n            if (_parentSchema19 && _parentSchema19.enum && _parentSchema19.enum.length === 1) {\n              return `${dataPath} should be ${this.getSchemaPartText(_parentSchema19, false, true)}`;\n            }\n            return `${dataPath} should be one of these:\\n${this.getSchemaPartText(_parentSchema19)}`;\n          }\n        case 'const':\n          {\n            var _parentSchema20 = error.parentSchema;\n            return `${dataPath} should be equal to constant ${this.getSchemaPartText(_parentSchema20, false, true)}`;\n          }\n        case 'not':\n          {\n            var postfix = likeObject(error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : '';\n            var schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n            if (canApplyNot(error.schema)) {\n              return `${dataPath} should be any ${schemaOutput}${postfix}.`;\n            }\n            var _schema = error.schema,\n              _parentSchema21 = error.parentSchema;\n            return `${dataPath} should not be ${this.getSchemaPartText(_schema, false, true)}${_parentSchema21 && likeObject(_parentSchema21) ? `\\n${this.getSchemaPartText(_parentSchema21)}` : ''}`;\n          }\n        case 'oneOf':\n        case 'anyOf':\n          {\n            var _parentSchema22 = error.parentSchema,\n              children = error.children;\n            if (children && children.length > 0) {\n              if (error.schema.length === 1) {\n                var lastChild = children[children.length - 1];\n                var remainingChildren = children.slice(0, children.length - 1);\n                return this.formatValidationError(Object.assign({}, lastChild, {\n                  children: remainingChildren,\n                  parentSchema: Object.assign({}, _parentSchema22, lastChild.parentSchema)\n                }));\n              }\n              var filteredChildren = filterChildren(children);\n              if (filteredChildren.length === 1) {\n                return this.formatValidationError(filteredChildren[0]);\n              }\n              filteredChildren = groupChildrenByFirstChild(filteredChildren);\n              return `${dataPath} should be one of these:\\n${this.getSchemaPartText(_parentSchema22)}\\nDetails:\\n${filteredChildren.map(function (nestedError) {\n                return ` * ${indent(_this3.formatValidationError(nestedError), '   ')}`;\n              }).join('\\n')}`;\n            }\n            return `${dataPath} should be one of these:\\n${this.getSchemaPartText(_parentSchema22)}`;\n          }\n        case 'if':\n          {\n            var _params17 = error.params,\n              _parentSchema23 = error.parentSchema;\n            var failingKeyword = _params17.failingKeyword;\n            return `${dataPath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(_parentSchema23, [failingKeyword])}`;\n          }\n        case 'absolutePath':\n          {\n            var message = error.message,\n              _parentSchema24 = error.parentSchema;\n            return `${dataPath}: ${message}${this.getSchemaPartDescription(_parentSchema24)}`;\n          }\n        default:\n          {\n            var _message = error.message,\n              _parentSchema25 = error.parentSchema;\n            var ErrorInJSON = JSON.stringify(error, null, 2);\n            return `${dataPath} ${_message} (${ErrorInJSON}).\\n${this.getSchemaPartText(_parentSchema25, false)}`;\n          }\n      }\n    }\n  }, {\n    key: \"formatValidationErrors\",\n    value: function formatValidationErrors(errors) {\n      var _this4 = this;\n      return errors.map(function (error) {\n        var formattedError = _this4.formatValidationError(error);\n        if (_this4.postFormatter) {\n          formattedError = _this4.postFormatter(formattedError, error);\n        }\n        return ` - ${indent(formattedError, '   ')}`;\n      }).join('\\n');\n    }\n  }]);\n}(_wrapNativeSuper(Error));\nvar _default = ValidationError;\nexports.default = _default;","map":{"version":3,"names":["_toConsumableArray","require","_toArray","_slicedToArray","_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_inherits","_wrapNativeSuper","_callSuper","t","o","e","_isNativeReflectConstruct","Reflect","construct","constructor","apply","Boolean","prototype","valueOf","call","Object","defineProperty","exports","value","default","_require","stringHints","numberHints","SPECIFICITY","type","not","oneOf","anyOf","if","enum","const","instanceof","required","pattern","patternRequired","format","formatMinimum","formatMaximum","minimum","exclusiveMinimum","maximum","exclusiveMaximum","multipleOf","uniqueItems","contains","minLength","maxLength","minItems","maxItems","minProperties","maxProperties","dependencies","propertyNames","additionalItems","additionalProperties","absolutePath","filterMax","array","fn","evaluatedMax","reduce","max","item","Math","filter","filterChildren","children","newChildren","error","dataPath","length","keyword","findAllChildren","schemaPaths","i","predicate","schemaPath","indexOf","every","refs","extractRefs","childrenStart","slice","concat","schema","Array","isArray","map","_ref","$ref","s","groupChildrenByFirstChild","result","child","push","assign","reverse","indent","str","prefix","replace","hasNotInSchema","findFirstTypedSchema","canApplyNot","typedSchema","likeNumber","likeInteger","likeString","likeNull","likeBoolean","isObject","maybeObj","likeArray","items","likeObject","properties","patternProperties","getArticle","test","getSchemaNonTypes","formatHints","hints","join","getHints","logic","ValidationError","_Error","errors","_this","configuration","arguments","undefined","name","headerNameFromSchema","baseDataPathFromSchema","title","baseDataPath","splittedTitleFromSchema","match","_splittedTitleFromSch","_splittedTitleFromSch2","headerName","postFormatter","header","message","formatValidationErrors","Error","captureStackTrace","key","getSchemaPart","path","newPath","split","schemaPart","inner","formatSchema","_this2","prevSchemas","newLogic","formatInnerSchema","innerSchema","addSelf","includes","needApplyLogicHere","values","JSON","stringify","allOf","ifValue","thenValue","then","elseValue","else","_getHints","_getHints2","_getHints3","_getHints4","hasAdditionalItems","keys","allProperties","Set","objectStructure","property","isRequired","forEach","dependencyName","dependency","dep","getSchemaPartText","additionalPath","needDot","schemaText","description","getSchemaPartDescription","formatValidationError","_this3","errorDataPath","parentSchema","params","comparison","limit","_getHints5","_getHints6","missingPattern","data","missingProperty","hasProperty","additionalProperty","deps","trim","propertyName","postfix","schemaOutput","lastChild","remainingChildren","filteredChildren","nestedError","failingKeyword","ErrorInJSON","_this4","formattedError","_default"],"sources":["C:/Users/user/Documents/app.v3/client/node_modules/@expo/webpack-config/node_modules/schema-utils/dist/ValidationError.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nconst {\n  stringHints,\n  numberHints\n} = require('./util/hints');\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n\n/** @enum {number} */\n\n\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.dataPath ? error.dataPath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[\n  /** @type {keyof typeof SPECIFICITY} */\n  error.keyword] || 2);\n  return newChildren;\n}\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\n\n\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === 'anyOf' || children[i].keyword === 'oneOf') {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n\n  return i + 1;\n}\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\n\n\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n\n  return schema.map(({\n    $ref\n  }) => $ref).filter(s => s);\n}\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n\n  while (i > 0) {\n    const child = children[i];\n\n    if (child.keyword === 'anyOf' || child.keyword === 'oneOf') {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n\n    i -= 1;\n  }\n\n  if (i === 0) {\n    result.push(children[i]);\n  }\n\n  return result.reverse();\n}\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\n\n\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\n\n\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n\n  return schema;\n}\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\n\n\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\n\n\nfunction isObject(maybeObj) {\n  return typeof maybeObj === 'object' && maybeObj !== null;\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNumber(schema) {\n  return schema.type === 'number' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeInteger(schema) {\n  return schema.type === 'integer' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeString(schema) {\n  return schema.type === 'string' || typeof schema.minLength !== 'undefined' || typeof schema.maxLength !== 'undefined' || typeof schema.pattern !== 'undefined' || typeof schema.format !== 'undefined' || typeof schema.formatMinimum !== 'undefined' || typeof schema.formatMaximum !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeBoolean(schema) {\n  return schema.type === 'boolean';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeArray(schema) {\n  return schema.type === 'array' || typeof schema.minItems === 'number' || typeof schema.maxItems === 'number' || typeof schema.uniqueItems !== 'undefined' || typeof schema.items !== 'undefined' || typeof schema.additionalItems !== 'undefined' || typeof schema.contains !== 'undefined';\n}\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\n\n\nfunction likeObject(schema) {\n  return schema.type === 'object' || typeof schema.minProperties !== 'undefined' || typeof schema.maxProperties !== 'undefined' || typeof schema.required !== 'undefined' || typeof schema.properties !== 'undefined' || typeof schema.patternProperties !== 'undefined' || typeof schema.additionalProperties !== 'undefined' || typeof schema.dependencies !== 'undefined' || typeof schema.propertyNames !== 'undefined' || typeof schema.patternRequired !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNull(schema) {\n  return schema.type === 'null';\n}\n/**\n * @param {string} type\n * @returns {string}\n */\n\n\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return 'an';\n  }\n\n  return 'a';\n}\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\n\n\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return '';\n  }\n\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return ' | should be any non-number';\n    }\n\n    if (likeString(schema)) {\n      return ' | should be any non-string';\n    }\n\n    if (likeArray(schema)) {\n      return ' | should be any non-array';\n    }\n\n    if (likeObject(schema)) {\n      return ' | should be any non-object';\n    }\n  }\n\n  return '';\n}\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\n\n\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(', ')})` : '';\n}\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\n\n\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    return numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    return stringHints(schema, logic);\n  }\n\n  return [];\n}\n\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema, configuration = {}) {\n    super();\n    /** @type {string} */\n\n    this.name = 'ValidationError';\n    /** @type {Array<SchemaUtilErrorObject>} */\n\n    this.errors = errors;\n    /** @type {Schema} */\n\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n    /** @type {string} */\n\n\n    this.headerName = configuration.name || headerNameFromSchema || 'Object';\n    /** @type {string} */\n\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || 'configuration';\n    /** @type {PostFormatter | null} */\n\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n    /** @type {string} */\n\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n\n\n  getSchemaPart(path) {\n    const newPath = path.split('/');\n    let schemaPart = this.schema;\n\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[\n      /** @type {keyof Schema} */\n      newPath[i]];\n\n      if (!inner) {\n        break;\n      }\n\n      schemaPart = inner;\n    }\n\n    return schemaPart;\n  }\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n\n\n  formatSchema(schema, logic = true, prevSchemas = []) {\n    let newLogic = logic;\n\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n\n      if (prevSchemas.includes(innerSchema)) {\n        return '(recursive)';\n      }\n\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? '' : 'non ';\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n\n    if (\n    /** @type {Schema & {instanceof: string | Array<string>}} */\n    schema.instanceof) {\n      const {\n        instanceof: value\n      } =\n      /** @type {Schema & {instanceof: string | Array<string>}} */\n      schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === 'Function' ? 'function' : item).join(' | ');\n    }\n\n    if (schema.enum) {\n      return (\n        /** @type {Array<any>} */\n        schema.enum.map(item => JSON.stringify(item)).join(' | ')\n      );\n    }\n\n    if (typeof schema.const !== 'undefined') {\n      return JSON.stringify(schema.const);\n    }\n\n    if (schema.oneOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.oneOf.map(item => formatInnerSchema(item, true)).join(' | ')\n      );\n    }\n\n    if (schema.anyOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.anyOf.map(item => formatInnerSchema(item, true)).join(' | ')\n      );\n    }\n\n    if (schema.allOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.allOf.map(item => formatInnerSchema(item, true)).join(' & ')\n      );\n    }\n\n    if (\n    /** @type {JSONSchema7} */\n    schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } =\n      /** @type {JSONSchema7} */\n      schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : ''}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : ''}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : ''}`;\n    }\n\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ''}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ''}`;\n      return logic ? str : str === 'string' ? 'non-string' : `non-string | ${str}`;\n    }\n\n    if (likeBoolean(schema)) {\n      return `${logic ? '' : 'non-'}boolean`;\n    }\n\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minItems === 'number') {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? 's' : ''}`);\n      }\n\n      if (typeof schema.maxItems === 'number') {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? 's' : ''}`);\n      }\n\n      if (schema.uniqueItems) {\n        hints.push('should not have duplicate items');\n      }\n\n      const hasAdditionalItems = typeof schema.additionalItems === 'undefined' || Boolean(schema.additionalItems);\n      let items = '';\n\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */\n          schema.items.map(item => formatInnerSchema(item)).join(', ')}`;\n\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = 'any';\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = 'any';\n      }\n\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n\n      return `[${items}${hasAdditionalItems ? ', ...' : ''}]${hints.length > 0 ? ` (${hints.join(', ')})` : ''}`;\n    }\n\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minProperties === 'number') {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? 'properties' : 'property'}`);\n      }\n\n      if (typeof schema.maxProperties === 'number') {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? 'properties' : 'property'}`);\n      }\n\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? 's' : ''} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(' | ')}`);\n      }\n\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set(\n      /** @type {Array<string>} */\n      [].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property); // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n\n        return `${property}${isRequired ? '' : '?'}`;\n      }).concat(typeof schema.additionalProperties === 'undefined' || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : ['…'] : []).join(', ');\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } =\n      /** @type {Schema & {patternRequired?: Array<string>;}} */\n      schema;\n\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? 'properties' : 'property'} ${dependency.map(dep => `'${dep}'`).join(', ')} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n\n      return `object {${objectStructure ? ` ${objectStructure} ` : ''}}${hints.length > 0 ? ` (${hints.join(', ')})` : ''}`;\n    }\n\n    if (likeNull(schema)) {\n      return `${logic ? '' : 'non-'}null`;\n    }\n\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(' | ')}`;\n    } // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n\n    /* istanbul ignore next */\n\n\n    return JSON.stringify(schema, null, 2);\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n\n\n  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {\n    if (!schemaPart) {\n      return '';\n    }\n\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[\n        /** @type {keyof Schema} */\n        additionalPath[i]];\n\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? '.' : ''}`;\n\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n\n    return schemaText;\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n\n\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return '';\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    if (schemaPart.description) {\n      return `\\n-> ${schemaPart.description}`;\n    }\n\n    return '';\n  }\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n\n\n  formatValidationError(error) {\n    const {\n      keyword,\n      dataPath: errorDataPath\n    } = error;\n    const dataPath = `${this.baseDataPath}${errorDataPath}`;\n\n    switch (keyword) {\n      case 'type':\n        {\n          const {\n            parentSchema,\n            params\n          } = error; // eslint-disable-next-line default-case\n\n          switch (\n          /** @type {import(\"ajv\").TypeParams} */\n          params.type) {\n            case 'number':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'integer':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'string':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'boolean':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'array':\n              return `${dataPath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case 'object':\n              return `${dataPath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case 'null':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            default:\n              return `${dataPath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n\n      case 'instanceof':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case 'pattern':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } =\n          /** @type {import(\"ajv\").PatternParams} */\n          params;\n          return `${dataPath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'format':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } =\n          /** @type {import(\"ajv\").FormatParams} */\n          params;\n          return `${dataPath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'formatMinimum':\n      case 'formatMaximum':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          return `${dataPath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minimum':\n      case 'maximum':\n      case 'exclusiveMinimum':\n      case 'exclusiveMaximum':\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          const [, ...hints] = getHints(\n          /** @type {Schema} */\n          parentSchema, true);\n\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n\n          return `${dataPath} ${hints.join(' ')}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'multipleOf':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } =\n          /** @type {import(\"ajv\").MultipleOfParams} */\n          params;\n          return `${dataPath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'patternRequired':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } =\n          /** @type {import(\"ajv\").PatternRequiredParams} */\n          params;\n          return `${dataPath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minLength':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          const length = limit - 1;\n          return `${dataPath} should be longer than ${length} character${length > 1 ? 's' : ''}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxLength':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          const max = limit + 1;\n          return `${dataPath} should be shorter than ${max} character${max > 1 ? 's' : ''}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'uniqueItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } =\n          /** @type {import(\"ajv\").UniqueItemsParams} */\n          params;\n          return `${dataPath} should not contain the item '${error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'additionalItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'contains':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should contains at least one ${this.getSchemaPartText(parentSchema, ['contains'])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n\n      case 'required':\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params.missingProperty.replace(/^\\./, '');\n          const hasProperty = parentSchema && Boolean(\n          /** @type {Schema} */\n          parentSchema.properties &&\n          /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${dataPath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, ['properties', missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'additionalProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } =\n          /** @type {import(\"ajv\").AdditionalPropertiesParams} */\n          params;\n          return `${dataPath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'dependencies':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params;\n          const dependencies = deps.split(',').map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(', ');\n          return `${dataPath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'propertyNames':\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } =\n          /** @type {import(\"ajv\").PropertyNamesParams} */\n          params;\n          return `${dataPath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'enum':\n        {\n          const {\n            parentSchema\n          } = error;\n\n          if (parentSchema &&\n          /** @type {Schema} */\n          parentSchema.enum &&\n          /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${dataPath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'const':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case 'not':\n        {\n          const postfix = likeObject(\n          /** @type {Schema} */\n          error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : '';\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n\n          if (canApplyNot(error.schema)) {\n            return `${dataPath} should be any ${schemaOutput}${postfix}.`;\n          }\n\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${dataPath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : ''}`;\n        }\n\n      case 'oneOf':\n      case 'anyOf':\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n\n            let filteredChildren = filterChildren(children);\n\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), '   ')}`).join('\\n')}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'if':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } =\n          /** @type {import(\"ajv\").IfParams} */\n          params;\n          return `${dataPath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n\n      case 'absolutePath':\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${dataPath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n\n          return `${dataPath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n\n\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n\n      return ` - ${indent(formattedError, '   ')}`;\n    }).join('\\n');\n  }\n\n}\n\nvar _default = ValidationError;\nexports.default = _default;"],"mappings":"AAAA,YAAY;;AAAC,IAAAA,kBAAA,GAAAC,OAAA;AAAA,IAAAC,QAAA,GAAAD,OAAA;AAAA,IAAAE,cAAA,GAAAF,OAAA;AAAA,IAAAG,eAAA,GAAAH,OAAA;AAAA,IAAAI,YAAA,GAAAJ,OAAA;AAAA,IAAAK,0BAAA,GAAAL,OAAA;AAAA,IAAAM,eAAA,GAAAN,OAAA;AAAA,IAAAO,SAAA,GAAAP,OAAA;AAAA,IAAAQ,gBAAA,GAAAR,OAAA;AAAA,SAAAS,WAAAC,CAAA,EAAAC,CAAA,EAAAC,CAAA,WAAAD,CAAA,GAAAL,eAAA,CAAAK,CAAA,GAAAN,0BAAA,CAAAK,CAAA,EAAAG,yBAAA,KAAAC,OAAA,CAAAC,SAAA,CAAAJ,CAAA,EAAAC,CAAA,QAAAN,eAAA,CAAAI,CAAA,EAAAM,WAAA,IAAAL,CAAA,CAAAM,KAAA,CAAAP,CAAA,EAAAE,CAAA;AAAA,SAAAC,0BAAA,cAAAH,CAAA,IAAAQ,OAAA,CAAAC,SAAA,CAAAC,OAAA,CAAAC,IAAA,CAAAP,OAAA,CAAAC,SAAA,CAAAG,OAAA,iCAAAR,CAAA,aAAAG,yBAAA,YAAAA,0BAAA,aAAAH,CAAA;AAEbY,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AAExB,IAAAC,QAAA,GAGI3B,OAAO,eAAe,CAAC;EAFzB4B,WAAW,GAAAD,QAAA,CAAXC,WAAW;EACXC,WAAW,GAAAF,QAAA,CAAXE,WAAW;AAiBb,IAAMC,WAAW,GAAG;EAClBC,IAAI,EAAE,CAAC;EACPC,GAAG,EAAE,CAAC;EACNC,KAAK,EAAE,CAAC;EACRC,KAAK,EAAE,CAAC;EACRC,EAAE,EAAE,CAAC;EACLC,IAAI,EAAE,CAAC;EACPC,KAAK,EAAE,CAAC;EACRC,UAAU,EAAE,CAAC;EACbC,QAAQ,EAAE,CAAC;EACXC,OAAO,EAAE,CAAC;EACVC,eAAe,EAAE,CAAC;EAClBC,MAAM,EAAE,CAAC;EACTC,aAAa,EAAE,CAAC;EAChBC,aAAa,EAAE,CAAC;EAChBC,OAAO,EAAE,CAAC;EACVC,gBAAgB,EAAE,CAAC;EACnBC,OAAO,EAAE,CAAC;EACVC,gBAAgB,EAAE,CAAC;EACnBC,UAAU,EAAE,CAAC;EACbC,WAAW,EAAE,CAAC;EACdC,QAAQ,EAAE,CAAC;EACXC,SAAS,EAAE,CAAC;EACZC,SAAS,EAAE,CAAC;EACZC,QAAQ,EAAE,CAAC;EACXC,QAAQ,EAAE,CAAC;EACXC,aAAa,EAAE,CAAC;EAChBC,aAAa,EAAE,CAAC;EAChBC,YAAY,EAAE,CAAC;EACfC,aAAa,EAAE,CAAC;EAChBC,eAAe,EAAE,CAAC;EAClBC,oBAAoB,EAAE,CAAC;EACvBC,YAAY,EAAE;AAChB,CAAC;AAQD,SAASC,SAASA,CAACC,KAAK,EAAEC,EAAE,EAAE;EAC5B,IAAMC,YAAY,GAAGF,KAAK,CAACG,MAAM,CAAC,UAACC,GAAG,EAAEC,IAAI;IAAA,OAAKC,IAAI,CAACF,GAAG,CAACA,GAAG,EAAEH,EAAE,CAACI,IAAI,CAAC,CAAC;EAAA,GAAE,CAAC,CAAC;EAC5E,OAAOL,KAAK,CAACO,MAAM,CAAC,UAAAF,IAAI;IAAA,OAAIJ,EAAE,CAACI,IAAI,CAAC,KAAKH,YAAY;EAAA,EAAC;AACxD;AAQA,SAASM,cAAcA,CAACC,QAAQ,EAAE;EAChC,IAAIC,WAAW,GAAGD,QAAQ;EAC1BC,WAAW,GAAGX,SAAS,CAACW,WAAW,EAMnC,UAAAC,KAAK;IAAA,OAAIA,KAAK,CAACC,QAAQ,GAAGD,KAAK,CAACC,QAAQ,CAACC,MAAM,GAAG,CAAC;EAAA,EAAC;EACpDH,WAAW,GAAGX,SAAS,CAACW,WAAW,EAKnC,UAAAC,KAAK;IAAA,OAAI7C,WAAW,CAEpB6C,KAAK,CAACG,OAAO,CAAC,IAAI,CAAC;EAAA,EAAC;EACpB,OAAOJ,WAAW;AACpB;AASA,SAASK,eAAeA,CAACN,QAAQ,EAAEO,WAAW,EAAE;EAC9C,IAAIC,CAAC,GAAGR,QAAQ,CAACI,MAAM,GAAG,CAAC;EAE3B,IAAMK,SAAS,GAKf,SALMA,SAASA,CAKfC,UAAU;IAAA,OAAIV,QAAQ,CAACQ,CAAC,CAAC,CAACE,UAAU,CAACC,OAAO,CAACD,UAAU,CAAC,KAAK,CAAC;EAAA;EAE9D,OAAOF,CAAC,GAAG,CAAC,CAAC,IAAI,CAACD,WAAW,CAACK,KAAK,CAACH,SAAS,CAAC,EAAE;IAC9C,IAAIT,QAAQ,CAACQ,CAAC,CAAC,CAACH,OAAO,KAAK,OAAO,IAAIL,QAAQ,CAACQ,CAAC,CAAC,CAACH,OAAO,KAAK,OAAO,EAAE;MACtE,IAAMQ,IAAI,GAAGC,WAAW,CAACd,QAAQ,CAACQ,CAAC,CAAC,CAAC;MACrC,IAAMO,aAAa,GAAGT,eAAe,CAACN,QAAQ,CAACgB,KAAK,CAAC,CAAC,EAAER,CAAC,CAAC,EAAEK,IAAI,CAACI,MAAM,CAACjB,QAAQ,CAACQ,CAAC,CAAC,CAACE,UAAU,CAAC,CAAC;MAChGF,CAAC,GAAGO,aAAa,GAAG,CAAC;IACvB,CAAC,MAAM;MACLP,CAAC,IAAI,CAAC;IACR;EACF;EAEA,OAAOA,CAAC,GAAG,CAAC;AACd;AAQA,SAASM,WAAWA,CAACZ,KAAK,EAAE;EAC1B,IACEgB,MAAM,GACJhB,KAAK,CADPgB,MAAM;EAGR,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,EAAE;IAC1B,OAAO,EAAE;EACX;EAEA,OAAOA,MAAM,CAACG,GAAG,CAAC,UAAAC,IAAA;IAAA,IAChBC,IAAI,GAAAD,IAAA,CAAJC,IAAI;IAAA,OACAA,IAAI;EAAA,EAAC,CAACzB,MAAM,CAAC,UAAA0B,CAAC;IAAA,OAAIA,CAAC;EAAA,EAAC;AAC5B;AAQA,SAASC,yBAAyBA,CAACzB,QAAQ,EAAE;EAC3C,IAAM0B,MAAM,GAAG,EAAE;EACjB,IAAIlB,CAAC,GAAGR,QAAQ,CAACI,MAAM,GAAG,CAAC;EAE3B,OAAOI,CAAC,GAAG,CAAC,EAAE;IACZ,IAAMmB,KAAK,GAAG3B,QAAQ,CAACQ,CAAC,CAAC;IAEzB,IAAImB,KAAK,CAACtB,OAAO,KAAK,OAAO,IAAIsB,KAAK,CAACtB,OAAO,KAAK,OAAO,EAAE;MAC1D,IAAMQ,IAAI,GAAGC,WAAW,CAACa,KAAK,CAAC;MAC/B,IAAMZ,aAAa,GAAGT,eAAe,CAACN,QAAQ,CAACgB,KAAK,CAAC,CAAC,EAAER,CAAC,CAAC,EAAEK,IAAI,CAACI,MAAM,CAACU,KAAK,CAACjB,UAAU,CAAC,CAAC;MAE1F,IAAIK,aAAa,KAAKP,CAAC,EAAE;QACvBkB,MAAM,CAACE,IAAI,CAAC/E,MAAM,CAACgF,MAAM,CAAC,CAAC,CAAC,EAAEF,KAAK,EAAE;UACnC3B,QAAQ,EAAEA,QAAQ,CAACgB,KAAK,CAACD,aAAa,EAAEP,CAAC;QAC3C,CAAC,CAAC,CAAC;QACHA,CAAC,GAAGO,aAAa;MACnB,CAAC,MAAM;QACLW,MAAM,CAACE,IAAI,CAACD,KAAK,CAAC;MACpB;IACF,CAAC,MAAM;MACLD,MAAM,CAACE,IAAI,CAACD,KAAK,CAAC;IACpB;IAEAnB,CAAC,IAAI,CAAC;EACR;EAEA,IAAIA,CAAC,KAAK,CAAC,EAAE;IACXkB,MAAM,CAACE,IAAI,CAAC5B,QAAQ,CAACQ,CAAC,CAAC,CAAC;EAC1B;EAEA,OAAOkB,MAAM,CAACI,OAAO,CAAC,CAAC;AACzB;AAQA,SAASC,MAAMA,CAACC,GAAG,EAAEC,MAAM,EAAE;EAC3B,OAAOD,GAAG,CAACE,OAAO,CAAC,UAAU,EAAE,KAAKD,MAAM,EAAE,CAAC;AAC/C;AAOA,SAASE,cAAcA,CAACjB,MAAM,EAAE;EAC9B,OAAO,CAAC,CAACA,MAAM,CAAC3D,GAAG;AACrB;AAOA,SAAS6E,oBAAoBA,CAAClB,MAAM,EAAE;EACpC,IAAIiB,cAAc,CAACjB,MAAM,CAAC,EAAE;IAC1B,OAAOkB,oBAAoB,CAAClB,MAAM,CAAC3D,GAAG,CAAC;EACzC;EAEA,OAAO2D,MAAM;AACf;AAOA,SAASmB,WAAWA,CAACnB,MAAM,EAAE;EAC3B,IAAMoB,WAAW,GAAGF,oBAAoB,CAAClB,MAAM,CAAC;EAChD,OAAOqB,UAAU,CAACD,WAAW,CAAC,IAAIE,WAAW,CAACF,WAAW,CAAC,IAAIG,UAAU,CAACH,WAAW,CAAC,IAAII,QAAQ,CAACJ,WAAW,CAAC,IAAIK,WAAW,CAACL,WAAW,CAAC;AAC5I;AAOA,SAASM,QAAQA,CAACC,QAAQ,EAAE;EAC1B,OAAO,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,IAAI;AAC1D;AAOA,SAASN,UAAUA,CAACrB,MAAM,EAAE;EAC1B,OAAOA,MAAM,CAAC5D,IAAI,KAAK,QAAQ,IAAI,OAAO4D,MAAM,CAAC9C,OAAO,KAAK,WAAW,IAAI,OAAO8C,MAAM,CAAC7C,gBAAgB,KAAK,WAAW,IAAI,OAAO6C,MAAM,CAAC5C,OAAO,KAAK,WAAW,IAAI,OAAO4C,MAAM,CAAC3C,gBAAgB,KAAK,WAAW,IAAI,OAAO2C,MAAM,CAAC1C,UAAU,KAAK,WAAW;AACnQ;AAOA,SAASgE,WAAWA,CAACtB,MAAM,EAAE;EAC3B,OAAOA,MAAM,CAAC5D,IAAI,KAAK,SAAS,IAAI,OAAO4D,MAAM,CAAC9C,OAAO,KAAK,WAAW,IAAI,OAAO8C,MAAM,CAAC7C,gBAAgB,KAAK,WAAW,IAAI,OAAO6C,MAAM,CAAC5C,OAAO,KAAK,WAAW,IAAI,OAAO4C,MAAM,CAAC3C,gBAAgB,KAAK,WAAW,IAAI,OAAO2C,MAAM,CAAC1C,UAAU,KAAK,WAAW;AACpQ;AAOA,SAASiE,UAAUA,CAACvB,MAAM,EAAE;EAC1B,OAAOA,MAAM,CAAC5D,IAAI,KAAK,QAAQ,IAAI,OAAO4D,MAAM,CAACvC,SAAS,KAAK,WAAW,IAAI,OAAOuC,MAAM,CAACtC,SAAS,KAAK,WAAW,IAAI,OAAOsC,MAAM,CAACnD,OAAO,KAAK,WAAW,IAAI,OAAOmD,MAAM,CAACjD,MAAM,KAAK,WAAW,IAAI,OAAOiD,MAAM,CAAChD,aAAa,KAAK,WAAW,IAAI,OAAOgD,MAAM,CAAC/C,aAAa,KAAK,WAAW;AACtS;AAOA,SAASwE,WAAWA,CAACzB,MAAM,EAAE;EAC3B,OAAOA,MAAM,CAAC5D,IAAI,KAAK,SAAS;AAClC;AAOA,SAASwF,SAASA,CAAC5B,MAAM,EAAE;EACzB,OAAOA,MAAM,CAAC5D,IAAI,KAAK,OAAO,IAAI,OAAO4D,MAAM,CAACrC,QAAQ,KAAK,QAAQ,IAAI,OAAOqC,MAAM,CAACpC,QAAQ,KAAK,QAAQ,IAAI,OAAOoC,MAAM,CAACzC,WAAW,KAAK,WAAW,IAAI,OAAOyC,MAAM,CAAC6B,KAAK,KAAK,WAAW,IAAI,OAAO7B,MAAM,CAAC/B,eAAe,KAAK,WAAW,IAAI,OAAO+B,MAAM,CAACxC,QAAQ,KAAK,WAAW;AAC7R;AAOA,SAASsE,UAAUA,CAAC9B,MAAM,EAAE;EAC1B,OAAOA,MAAM,CAAC5D,IAAI,KAAK,QAAQ,IAAI,OAAO4D,MAAM,CAACnC,aAAa,KAAK,WAAW,IAAI,OAAOmC,MAAM,CAAClC,aAAa,KAAK,WAAW,IAAI,OAAOkC,MAAM,CAACpD,QAAQ,KAAK,WAAW,IAAI,OAAOoD,MAAM,CAAC+B,UAAU,KAAK,WAAW,IAAI,OAAO/B,MAAM,CAACgC,iBAAiB,KAAK,WAAW,IAAI,OAAOhC,MAAM,CAAC9B,oBAAoB,KAAK,WAAW,IAAI,OAAO8B,MAAM,CAACjC,YAAY,KAAK,WAAW,IAAI,OAAOiC,MAAM,CAAChC,aAAa,KAAK,WAAW,IAAI,OAAOgC,MAAM,CAAClD,eAAe,KAAK,WAAW;AAC5c;AAOA,SAAS0E,QAAQA,CAACxB,MAAM,EAAE;EACxB,OAAOA,MAAM,CAAC5D,IAAI,KAAK,MAAM;AAC/B;AAOA,SAAS6F,UAAUA,CAAC7F,IAAI,EAAE;EACxB,IAAI,WAAW,CAAC8F,IAAI,CAAC9F,IAAI,CAAC,EAAE;IAC1B,OAAO,IAAI;EACb;EAEA,OAAO,GAAG;AACZ;AAOA,SAAS+F,iBAAiBA,CAACnC,MAAM,EAAE;EACjC,IAAI,CAACA,MAAM,EAAE;IACX,OAAO,EAAE;EACX;EAEA,IAAI,CAACA,MAAM,CAAC5D,IAAI,EAAE;IAChB,IAAIiF,UAAU,CAACrB,MAAM,CAAC,IAAIsB,WAAW,CAACtB,MAAM,CAAC,EAAE;MAC7C,OAAO,6BAA6B;IACtC;IAEA,IAAIuB,UAAU,CAACvB,MAAM,CAAC,EAAE;MACtB,OAAO,6BAA6B;IACtC;IAEA,IAAI4B,SAAS,CAAC5B,MAAM,CAAC,EAAE;MACrB,OAAO,4BAA4B;IACrC;IAEA,IAAI8B,UAAU,CAAC9B,MAAM,CAAC,EAAE;MACtB,OAAO,6BAA6B;IACtC;EACF;EAEA,OAAO,EAAE;AACX;AAOA,SAASoC,WAAWA,CAACC,KAAK,EAAE;EAC1B,OAAOA,KAAK,CAACnD,MAAM,GAAG,CAAC,GAAG,IAAImD,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,EAAE;AACxD;AAQA,SAASC,QAAQA,CAACvC,MAAM,EAAEwC,KAAK,EAAE;EAC/B,IAAInB,UAAU,CAACrB,MAAM,CAAC,IAAIsB,WAAW,CAACtB,MAAM,CAAC,EAAE;IAC7C,OAAO9D,WAAW,CAAC8D,MAAM,EAAEwC,KAAK,CAAC;EACnC,CAAC,MAAM,IAAIjB,UAAU,CAACvB,MAAM,CAAC,EAAE;IAC7B,OAAO/D,WAAW,CAAC+D,MAAM,EAAEwC,KAAK,CAAC;EACnC;EAEA,OAAO,EAAE;AACX;AAAC,IAEKC,eAAe,aAAAC,MAAA;EAMnB,SAAAD,gBAAYE,MAAM,EAAE3C,MAAM,EAAsB;IAAA,IAAA4C,KAAA;IAAA,IAApBC,aAAa,GAAAC,SAAA,CAAA5D,MAAA,QAAA4D,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;IAAAtI,eAAA,OAAAiI,eAAA;IAC5CG,KAAA,GAAA9H,UAAA,OAAA2H,eAAA;IAGAG,KAAA,CAAKI,IAAI,GAAG,iBAAiB;IAG7BJ,KAAA,CAAKD,MAAM,GAAGA,MAAM;IAGpBC,KAAA,CAAK5C,MAAM,GAAGA,MAAM;IACpB,IAAIiD,oBAAoB;IACxB,IAAIC,sBAAsB;IAE1B,IAAIlD,MAAM,CAACmD,KAAK,KAAK,CAACN,aAAa,CAACG,IAAI,IAAI,CAACH,aAAa,CAACO,YAAY,CAAC,EAAE;MACxE,IAAMC,uBAAuB,GAAGrD,MAAM,CAACmD,KAAK,CAACG,KAAK,CAAC,aAAa,CAAC;MAEjE,IAAID,uBAAuB,EAAE;QAC3B,IAAI,CAACR,aAAa,CAACG,IAAI,EAAE;UAAA,IAAAO,qBAAA,GAAAhJ,cAAA,CACI8I,uBAAuB;UAA/CJ,oBAAoB,GAAAM,qBAAA;QACzB;QAEA,IAAI,CAACV,aAAa,CAACO,YAAY,EAAE;UAAA,IAAAI,sBAAA,GAAAjJ,cAAA,CACD8I,uBAAuB;UAAjDH,sBAAsB,GAAAM,sBAAA;QAC5B;MACF;IACF;IAIAZ,KAAA,CAAKa,UAAU,GAAGZ,aAAa,CAACG,IAAI,IAAIC,oBAAoB,IAAI,QAAQ;IAGxEL,KAAA,CAAKQ,YAAY,GAAGP,aAAa,CAACO,YAAY,IAAIF,sBAAsB,IAAI,eAAe;IAG3FN,KAAA,CAAKc,aAAa,GAAGb,aAAa,CAACa,aAAa,IAAI,IAAI;IACxD,IAAMC,MAAM,GAAG,WAAWf,KAAA,CAAKQ,YAAY,YAAYR,KAAA,CAAKa,UAAU,+BAA+BxB,UAAU,CAACW,KAAA,CAAKQ,YAAY,CAAC,IAAIR,KAAA,CAAKQ,YAAY,+CAA+C;IAGtMR,KAAA,CAAKgB,OAAO,GAAG,GAAGD,MAAM,GAAGf,KAAA,CAAKiB,sBAAsB,CAAClB,MAAM,CAAC,EAAE;IAChEmB,KAAK,CAACC,iBAAiB,CAAAnB,KAAA,EAAOA,KAAA,CAAKvH,WAAW,CAAC;IAAC,OAAAuH,KAAA;EAClD;EAAChI,SAAA,CAAA6H,eAAA,EAAAC,MAAA;EAAA,OAAAjI,YAAA,CAAAgI,eAAA;IAAAuB,GAAA;IAAAlI,KAAA,EAOD,SAAAmI,aAAaA,CAACC,IAAI,EAAE;MAClB,IAAMC,OAAO,GAAGD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC;MAC/B,IAAIC,UAAU,GAAG,IAAI,CAACrE,MAAM;MAE5B,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6E,OAAO,CAACjF,MAAM,EAAEI,CAAC,EAAE,EAAE;QACvC,IAAMgF,KAAK,GAAGD,UAAU,CAExBF,OAAO,CAAC7E,CAAC,CAAC,CAAC;QAEX,IAAI,CAACgF,KAAK,EAAE;UACV;QACF;QAEAD,UAAU,GAAGC,KAAK;MACpB;MAEA,OAAOD,UAAU;IACnB;EAAC;IAAAL,GAAA;IAAAlI,KAAA,EASD,SAAAyI,YAAYA,CAACvE,MAAM,EAAkC;MAAA,IAAAwE,MAAA;MAAA,IAAhChC,KAAK,GAAAM,SAAA,CAAA5D,MAAA,QAAA4D,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAI;MAAA,IAAE2B,WAAW,GAAA3B,SAAA,CAAA5D,MAAA,QAAA4D,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EAAE;MACjD,IAAI4B,QAAQ,GAAGlC,KAAK;MAEpB,IAAMmC,iBAAiB,GAOvB,SAPMA,iBAAiBA,CAOtBC,WAAW,EAAEC,OAAO,EAAK;QACxB,IAAI,CAACA,OAAO,EAAE;UACZ,OAAOL,MAAI,CAACD,YAAY,CAACK,WAAW,EAAEF,QAAQ,EAAED,WAAW,CAAC;QAC9D;QAEA,IAAIA,WAAW,CAACK,QAAQ,CAACF,WAAW,CAAC,EAAE;UACrC,OAAO,aAAa;QACtB;QAEA,OAAOJ,MAAI,CAACD,YAAY,CAACK,WAAW,EAAEF,QAAQ,EAAED,WAAW,CAAC1E,MAAM,CAACC,MAAM,CAAC,CAAC;MAC7E,CAAC;MAED,IAAIiB,cAAc,CAACjB,MAAM,CAAC,IAAI,CAAC8B,UAAU,CAAC9B,MAAM,CAAC,EAAE;QACjD,IAAImB,WAAW,CAACnB,MAAM,CAAC3D,GAAG,CAAC,EAAE;UAC3BqI,QAAQ,GAAG,CAAClC,KAAK;UACjB,OAAOmC,iBAAiB,CAAC3E,MAAM,CAAC3D,GAAG,CAAC;QACtC;QAEA,IAAM0I,kBAAkB,GAAG,CAAC/E,MAAM,CAAC3D,GAAG,CAACA,GAAG;QAC1C,IAAM0E,MAAM,GAAGyB,KAAK,GAAG,EAAE,GAAG,MAAM;QAClCkC,QAAQ,GAAG,CAAClC,KAAK;QACjB,OAAOuC,kBAAkB,GAAGhE,MAAM,GAAG4D,iBAAiB,CAAC3E,MAAM,CAAC3D,GAAG,CAAC,GAAGsI,iBAAiB,CAAC3E,MAAM,CAAC3D,GAAG,CAAC;MACpG;MAEA,IAEA2D,MAAM,CAACrD,UAAU,EAAE;QACjB,IACcb,KAAK,GAGnBkE,MAAM,CAHJrD,UAAU;QAIZ,IAAMqI,MAAM,GAAG,CAAC/E,KAAK,CAACC,OAAO,CAACpE,KAAK,CAAC,GAAG,CAACA,KAAK,CAAC,GAAGA,KAAK;QACtD,OAAOkJ,MAAM,CAAC7E,GAAG,CAKjB,UAAAzB,IAAI;UAAA,OAAIA,IAAI,KAAK,UAAU,GAAG,UAAU,GAAGA,IAAI;QAAA,EAAC,CAAC4D,IAAI,CAAC,KAAK,CAAC;MAC9D;MAEA,IAAItC,MAAM,CAACvD,IAAI,EAAE;QACf,OAEEuD,MAAM,CAACvD,IAAI,CAAC0D,GAAG,CAAC,UAAAzB,IAAI;UAAA,OAAIuG,IAAI,CAACC,SAAS,CAACxG,IAAI,CAAC;QAAA,EAAC,CAAC4D,IAAI,CAAC,KAAK,CAAC;MAE7D;MAEA,IAAI,OAAOtC,MAAM,CAACtD,KAAK,KAAK,WAAW,EAAE;QACvC,OAAOuI,IAAI,CAACC,SAAS,CAAClF,MAAM,CAACtD,KAAK,CAAC;MACrC;MAEA,IAAIsD,MAAM,CAAC1D,KAAK,EAAE;QAChB,OAEE0D,MAAM,CAAC1D,KAAK,CAAC6D,GAAG,CAAC,UAAAzB,IAAI;UAAA,OAAIiG,iBAAiB,CAACjG,IAAI,EAAE,IAAI,CAAC;QAAA,EAAC,CAAC4D,IAAI,CAAC,KAAK,CAAC;MAEvE;MAEA,IAAItC,MAAM,CAACzD,KAAK,EAAE;QAChB,OAEEyD,MAAM,CAACzD,KAAK,CAAC4D,GAAG,CAAC,UAAAzB,IAAI;UAAA,OAAIiG,iBAAiB,CAACjG,IAAI,EAAE,IAAI,CAAC;QAAA,EAAC,CAAC4D,IAAI,CAAC,KAAK,CAAC;MAEvE;MAEA,IAAItC,MAAM,CAACmF,KAAK,EAAE;QAChB,OAEEnF,MAAM,CAACmF,KAAK,CAAChF,GAAG,CAAC,UAAAzB,IAAI;UAAA,OAAIiG,iBAAiB,CAACjG,IAAI,EAAE,IAAI,CAAC;QAAA,EAAC,CAAC4D,IAAI,CAAC,KAAK,CAAC;MAEvE;MAEA,IAEAtC,MAAM,CAACxD,EAAE,EAAE;QACT,IACM4I,OAAO,GAKbpF,MAAM,CALJxD,EAAE;UACI6I,SAAS,GAIjBrF,MAAM,CAJJsF,IAAI;UACEC,SAAS,GAGjBvF,MAAM,CAHJwF,IAAI;QAIN,OAAO,GAAGJ,OAAO,GAAG,MAAMT,iBAAiB,CAACS,OAAO,CAAC,EAAE,GAAG,EAAE,GAAGC,SAAS,GAAG,SAASV,iBAAiB,CAACU,SAAS,CAAC,EAAE,GAAG,EAAE,GAAGE,SAAS,GAAG,SAASZ,iBAAiB,CAACY,SAAS,CAAC,EAAE,GAAG,EAAE,EAAE;MACrL;MAEA,IAAIvF,MAAM,CAACK,IAAI,EAAE;QACf,OAAOsE,iBAAiB,CAAC,IAAI,CAACV,aAAa,CAACjE,MAAM,CAACK,IAAI,CAAC,EAAE,IAAI,CAAC;MACjE;MAEA,IAAIgB,UAAU,CAACrB,MAAM,CAAC,IAAIsB,WAAW,CAACtB,MAAM,CAAC,EAAE;QAC7C,IAAAyF,SAAA,GAAyBlD,QAAQ,CAACvC,MAAM,EAAEwC,KAAK,CAAC;UAAAkD,UAAA,GAAApL,QAAA,CAAAmL,SAAA;UAAzCrJ,IAAI,GAAAsJ,UAAA;UAAKrD,KAAK,GAAAqD,UAAA,CAAA5F,KAAA;QACrB,IAAMgB,GAAG,GAAG,GAAG1E,IAAI,GAAGiG,KAAK,CAACnD,MAAM,GAAG,CAAC,GAAG,IAAIkD,WAAW,CAACC,KAAK,CAAC,EAAE,GAAG,EAAE,EAAE;QACxE,OAAOG,KAAK,GAAG1B,GAAG,GAAGuB,KAAK,CAACnD,MAAM,GAAG,CAAC,GAAG,OAAO9C,IAAI,MAAM0E,GAAG,EAAE,GAAG,OAAO1E,IAAI,EAAE;MAChF;MAEA,IAAImF,UAAU,CAACvB,MAAM,CAAC,EAAE;QACtB,IAAA2F,UAAA,GAAyBpD,QAAQ,CAACvC,MAAM,EAAEwC,KAAK,CAAC;UAAAoD,UAAA,GAAAtL,QAAA,CAAAqL,UAAA;UAAzCvJ,KAAI,GAAAwJ,UAAA;UAAKvD,MAAK,GAAAuD,UAAA,CAAA9F,KAAA;QACrB,IAAMgB,IAAG,GAAG,GAAG1E,KAAI,GAAGiG,MAAK,CAACnD,MAAM,GAAG,CAAC,GAAG,IAAIkD,WAAW,CAACC,MAAK,CAAC,EAAE,GAAG,EAAE,EAAE;QACxE,OAAOG,KAAK,GAAG1B,IAAG,GAAGA,IAAG,KAAK,QAAQ,GAAG,YAAY,GAAG,gBAAgBA,IAAG,EAAE;MAC9E;MAEA,IAAIW,WAAW,CAACzB,MAAM,CAAC,EAAE;QACvB,OAAO,GAAGwC,KAAK,GAAG,EAAE,GAAG,MAAM,SAAS;MACxC;MAEA,IAAIZ,SAAS,CAAC5B,MAAM,CAAC,EAAE;QAErB0E,QAAQ,GAAG,IAAI;QACf,IAAMrC,OAAK,GAAG,EAAE;QAEhB,IAAI,OAAOrC,MAAM,CAACrC,QAAQ,KAAK,QAAQ,EAAE;UACvC0E,OAAK,CAAC3B,IAAI,CAAC,8BAA8BV,MAAM,CAACrC,QAAQ,QAAQqC,MAAM,CAACrC,QAAQ,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,EAAE,CAAC;QACnG;QAEA,IAAI,OAAOqC,MAAM,CAACpC,QAAQ,KAAK,QAAQ,EAAE;UACvCyE,OAAK,CAAC3B,IAAI,CAAC,6BAA6BV,MAAM,CAACpC,QAAQ,QAAQoC,MAAM,CAACpC,QAAQ,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,EAAE,CAAC;QAClG;QAEA,IAAIoC,MAAM,CAACzC,WAAW,EAAE;UACtB8E,OAAK,CAAC3B,IAAI,CAAC,iCAAiC,CAAC;QAC/C;QAEA,IAAMmF,kBAAkB,GAAG,OAAO7F,MAAM,CAAC/B,eAAe,KAAK,WAAW,IAAI1C,OAAO,CAACyE,MAAM,CAAC/B,eAAe,CAAC;QAC3G,IAAI4D,KAAK,GAAG,EAAE;QAEd,IAAI7B,MAAM,CAAC6B,KAAK,EAAE;UAChB,IAAI5B,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC6B,KAAK,CAAC,IAAI7B,MAAM,CAAC6B,KAAK,CAAC3C,MAAM,GAAG,CAAC,EAAE;YAC1D2C,KAAK,GAAG,GAER7B,MAAM,CAAC6B,KAAK,CAAC1B,GAAG,CAAC,UAAAzB,IAAI;cAAA,OAAIiG,iBAAiB,CAACjG,IAAI,CAAC;YAAA,EAAC,CAAC4D,IAAI,CAAC,IAAI,CAAC,EAAE;YAE9D,IAAIuD,kBAAkB,EAAE;cACtB,IAAI7F,MAAM,CAAC/B,eAAe,IAAIyD,QAAQ,CAAC1B,MAAM,CAAC/B,eAAe,CAAC,IAAItC,MAAM,CAACmK,IAAI,CAAC9F,MAAM,CAAC/B,eAAe,CAAC,CAACiB,MAAM,GAAG,CAAC,EAAE;gBAChHmD,OAAK,CAAC3B,IAAI,CAAC,8BAA8BiE,iBAAiB,CAAC3E,MAAM,CAAC/B,eAAe,CAAC,EAAE,CAAC;cACvF;YACF;UACF,CAAC,MAAM,IAAI+B,MAAM,CAAC6B,KAAK,IAAIlG,MAAM,CAACmK,IAAI,CAAC9F,MAAM,CAAC6B,KAAK,CAAC,CAAC3C,MAAM,GAAG,CAAC,EAAE;YAE/D2C,KAAK,GAAG,GAAG8C,iBAAiB,CAAC3E,MAAM,CAAC6B,KAAK,CAAC,EAAE;UAC9C,CAAC,MAAM;YAELA,KAAK,GAAG,KAAK;UACf;QACF,CAAC,MAAM;UAELA,KAAK,GAAG,KAAK;QACf;QAEA,IAAI7B,MAAM,CAACxC,QAAQ,IAAI7B,MAAM,CAACmK,IAAI,CAAC9F,MAAM,CAACxC,QAAQ,CAAC,CAAC0B,MAAM,GAAG,CAAC,EAAE;UAC9DmD,OAAK,CAAC3B,IAAI,CAAC,gCAAgC,IAAI,CAAC6D,YAAY,CAACvE,MAAM,CAACxC,QAAQ,CAAC,OAAO,CAAC;QACvF;QAEA,OAAO,IAAIqE,KAAK,GAAGgE,kBAAkB,GAAG,OAAO,GAAG,EAAE,IAAIxD,OAAK,CAACnD,MAAM,GAAG,CAAC,GAAG,KAAKmD,OAAK,CAACC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,EAAE,EAAE;MAC5G;MAEA,IAAIR,UAAU,CAAC9B,MAAM,CAAC,EAAE;QAEtB0E,QAAQ,GAAG,IAAI;QACf,IAAMrC,OAAK,GAAG,EAAE;QAEhB,IAAI,OAAOrC,MAAM,CAACnC,aAAa,KAAK,QAAQ,EAAE;UAC5CwE,OAAK,CAAC3B,IAAI,CAAC,8BAA8BV,MAAM,CAACnC,aAAa,IAAImC,MAAM,CAACnC,aAAa,GAAG,CAAC,GAAG,YAAY,GAAG,UAAU,EAAE,CAAC;QAC1H;QAEA,IAAI,OAAOmC,MAAM,CAAClC,aAAa,KAAK,QAAQ,EAAE;UAC5CuE,OAAK,CAAC3B,IAAI,CAAC,6BAA6BV,MAAM,CAAClC,aAAa,IAAIkC,MAAM,CAACnC,aAAa,IAAImC,MAAM,CAACnC,aAAa,GAAG,CAAC,GAAG,YAAY,GAAG,UAAU,EAAE,CAAC;QACjJ;QAEA,IAAImC,MAAM,CAACgC,iBAAiB,IAAIrG,MAAM,CAACmK,IAAI,CAAC9F,MAAM,CAACgC,iBAAiB,CAAC,CAAC9C,MAAM,GAAG,CAAC,EAAE;UAChF,IAAM8C,iBAAiB,GAAGrG,MAAM,CAACmK,IAAI,CAAC9F,MAAM,CAACgC,iBAAiB,CAAC;UAC/DK,OAAK,CAAC3B,IAAI,CAAC,iDAAiDsB,iBAAiB,CAAC9C,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,IAAI8C,iBAAiB,CAAC7B,GAAG,CAAC,UAAAtD,OAAO;YAAA,OAAIoI,IAAI,CAACC,SAAS,CAACrI,OAAO,CAAC;UAAA,EAAC,CAACyF,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QACjL;QAEA,IAAMP,UAAU,GAAG/B,MAAM,CAAC+B,UAAU,GAAGpG,MAAM,CAACmK,IAAI,CAAC9F,MAAM,CAAC+B,UAAU,CAAC,GAAG,EAAE;QAC1E,IAAMnF,QAAQ,GAAGoD,MAAM,CAACpD,QAAQ,GAAGoD,MAAM,CAACpD,QAAQ,GAAG,EAAE;QACvD,IAAMmJ,aAAa,GAAA3L,kBAAA,CAAO,IAAI4L,GAAG,CAEjC,EAAE,CAACjG,MAAM,CAACnD,QAAQ,CAAC,CAACmD,MAAM,CAACgC,UAAU,CAAC,CAAC,CAAC;QACxC,IAAMkE,eAAe,GAAGF,aAAa,CAAC5F,GAAG,CAAC,UAAA+F,QAAQ,EAAI;UACpD,IAAMC,UAAU,GAAGvJ,QAAQ,CAACkI,QAAQ,CAACoB,QAAQ,CAAC;UAG9C,OAAO,GAAGA,QAAQ,GAAGC,UAAU,GAAG,EAAE,GAAG,GAAG,EAAE;QAC9C,CAAC,CAAC,CAACpG,MAAM,CAAC,OAAOC,MAAM,CAAC9B,oBAAoB,KAAK,WAAW,IAAI3C,OAAO,CAACyE,MAAM,CAAC9B,oBAAoB,CAAC,GAAG8B,MAAM,CAAC9B,oBAAoB,IAAIwD,QAAQ,CAAC1B,MAAM,CAAC9B,oBAAoB,CAAC,GAAG,CAAC,UAAUyG,iBAAiB,CAAC3E,MAAM,CAAC9B,oBAAoB,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAACoE,IAAI,CAAC,IAAI,CAAC;QACnQ,IACEvE,YAAY,GAKdiC,MAAM,CALJjC,YAAY;UACZC,aAAa,GAIfgC,MAAM,CAJJhC,aAAa;UACblB,eAAe,GAGjBkD,MAAM,CAHJlD,eAAe;QAKjB,IAAIiB,YAAY,EAAE;UAChBpC,MAAM,CAACmK,IAAI,CAAC/H,YAAY,CAAC,CAACqI,OAAO,CAAC,UAAAC,cAAc,EAAI;YAClD,IAAMC,UAAU,GAAGvI,YAAY,CAACsI,cAAc,CAAC;YAE/C,IAAIpG,KAAK,CAACC,OAAO,CAACoG,UAAU,CAAC,EAAE;cAC7BjE,OAAK,CAAC3B,IAAI,CAAC,eAAe4F,UAAU,CAACpH,MAAM,GAAG,CAAC,GAAG,YAAY,GAAG,UAAU,IAAIoH,UAAU,CAACnG,GAAG,CAAC,UAAAoG,GAAG;gBAAA,OAAI,IAAIA,GAAG,GAAG;cAAA,EAAC,CAACjE,IAAI,CAAC,IAAI,CAAC,mBAAmB+D,cAAc,cAAc,CAAC;YAC7K,CAAC,MAAM;cACLhE,OAAK,CAAC3B,IAAI,CAAC,2CAA2CiE,iBAAiB,CAAC2B,UAAU,CAAC,mBAAmBD,cAAc,cAAc,CAAC;YACrI;UACF,CAAC,CAAC;QACJ;QAEA,IAAIrI,aAAa,IAAIrC,MAAM,CAACmK,IAAI,CAAC9H,aAAa,CAAC,CAACkB,MAAM,GAAG,CAAC,EAAE;UAC1DmD,OAAK,CAAC3B,IAAI,CAAC,0CAA0CuE,IAAI,CAACC,SAAS,CAAClF,MAAM,CAAChC,aAAa,CAACjB,MAAM,CAAC,EAAE,CAAC;QACrG;QAEA,IAAID,eAAe,IAAIA,eAAe,CAACoC,MAAM,GAAG,CAAC,EAAE;UACjDmD,OAAK,CAAC3B,IAAI,CAAC,yCAAyC5D,eAAe,CAACqD,GAAG,CAKvE,UAAAzB,IAAI;YAAA,OAAIuG,IAAI,CAACC,SAAS,CAACxG,IAAI,CAAC;UAAA,EAAC,EAAE,CAAC;QAClC;QAEA,OAAO,WAAWuH,eAAe,GAAG,IAAIA,eAAe,GAAG,GAAG,EAAE,IAAI5D,OAAK,CAACnD,MAAM,GAAG,CAAC,GAAG,KAAKmD,OAAK,CAACC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,EAAE,EAAE;MACvH;MAEA,IAAId,QAAQ,CAACxB,MAAM,CAAC,EAAE;QACpB,OAAO,GAAGwC,KAAK,GAAG,EAAE,GAAG,MAAM,MAAM;MACrC;MAEA,IAAIvC,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC5D,IAAI,CAAC,EAAE;QAE9B,OAAO,GAAG4D,MAAM,CAAC5D,IAAI,CAACkG,IAAI,CAAC,KAAK,CAAC,EAAE;MACrC;MAMA,OAAO2C,IAAI,CAACC,SAAS,CAAClF,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;IACxC;EAAC;IAAAgE,GAAA;IAAAlI,KAAA,EAUD,SAAA0K,iBAAiBA,CAACnC,UAAU,EAAEoC,cAAc,EAAiC;MAAA,IAA/BC,OAAO,GAAA5D,SAAA,CAAA5D,MAAA,QAAA4D,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;MAAA,IAAEN,KAAK,GAAAM,SAAA,CAAA5D,MAAA,QAAA4D,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAI;MACzE,IAAI,CAACuB,UAAU,EAAE;QACf,OAAO,EAAE;MACX;MAEA,IAAIpE,KAAK,CAACC,OAAO,CAACuG,cAAc,CAAC,EAAE;QACjC,KAAK,IAAInH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmH,cAAc,CAACvH,MAAM,EAAEI,CAAC,EAAE,EAAE;UAE9C,IAAMgF,KAAK,GAAGD,UAAU,CAExBoC,cAAc,CAACnH,CAAC,CAAC,CAAC;UAElB,IAAIgF,KAAK,EAAE;YAETD,UAAU,GAAGC,KAAK;UACpB,CAAC,MAAM;YACL;UACF;QACF;MACF;MAEA,OAAOD,UAAU,CAAChE,IAAI,EAAE;QAEtBgE,UAAU,GAAG,IAAI,CAACJ,aAAa,CAACI,UAAU,CAAChE,IAAI,CAAC;MAClD;MAEA,IAAIsG,UAAU,GAAG,GAAG,IAAI,CAACpC,YAAY,CAACF,UAAU,EAAE7B,KAAK,CAAC,GAAGkE,OAAO,GAAG,GAAG,GAAG,EAAE,EAAE;MAE/E,IAAIrC,UAAU,CAACuC,WAAW,EAAE;QAC1BD,UAAU,IAAI,QAAQtC,UAAU,CAACuC,WAAW,EAAE;MAChD;MAEA,OAAOD,UAAU;IACnB;EAAC;IAAA3C,GAAA;IAAAlI,KAAA,EAOD,SAAA+K,wBAAwBA,CAACxC,UAAU,EAAE;MACnC,IAAI,CAACA,UAAU,EAAE;QACf,OAAO,EAAE;MACX;MAEA,OAAOA,UAAU,CAAChE,IAAI,EAAE;QAEtBgE,UAAU,GAAG,IAAI,CAACJ,aAAa,CAACI,UAAU,CAAChE,IAAI,CAAC;MAClD;MAEA,IAAIgE,UAAU,CAACuC,WAAW,EAAE;QAC1B,OAAO,QAAQvC,UAAU,CAACuC,WAAW,EAAE;MACzC;MAEA,OAAO,EAAE;IACX;EAAC;IAAA5C,GAAA;IAAAlI,KAAA,EAOD,SAAAgL,qBAAqBA,CAAC9H,KAAK,EAAE;MAAA,IAAA+H,MAAA;MAC3B,IACE5H,OAAO,GAELH,KAAK,CAFPG,OAAO;QACG6H,aAAa,GACrBhI,KAAK,CADPC,QAAQ;MAEV,IAAMA,QAAQ,GAAG,GAAG,IAAI,CAACmE,YAAY,GAAG4D,aAAa,EAAE;MAEvD,QAAQ7H,OAAO;QACb,KAAK,MAAM;UACT;YACE,IACE8H,YAAY,GAEVjI,KAAK,CAFPiI,YAAY;cACZC,MAAM,GACJlI,KAAK,CADPkI,MAAM;YAGR,QAEAA,MAAM,CAAC9K,IAAI;cACT,KAAK,QAAQ;gBACX,OAAO,GAAG6C,QAAQ,gBAAgB,IAAI,CAACuH,iBAAiB,CAACS,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;cAEvF,KAAK,SAAS;gBACZ,OAAO,GAAGhI,QAAQ,gBAAgB,IAAI,CAACuH,iBAAiB,CAACS,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;cAEvF,KAAK,QAAQ;gBACX,OAAO,GAAGhI,QAAQ,gBAAgB,IAAI,CAACuH,iBAAiB,CAACS,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;cAEvF,KAAK,SAAS;gBACZ,OAAO,GAAGhI,QAAQ,gBAAgB,IAAI,CAACuH,iBAAiB,CAACS,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;cAEvF,KAAK,OAAO;gBACV,OAAO,GAAGhI,QAAQ,yBAAyB,IAAI,CAACuH,iBAAiB,CAACS,YAAY,CAAC,EAAE;cAEnF,KAAK,QAAQ;gBACX,OAAO,GAAGhI,QAAQ,0BAA0B,IAAI,CAACuH,iBAAiB,CAACS,YAAY,CAAC,EAAE;cAEpF,KAAK,MAAM;gBACT,OAAO,GAAGhI,QAAQ,gBAAgB,IAAI,CAACuH,iBAAiB,CAACS,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;cAEvF;gBACE,OAAO,GAAGhI,QAAQ,gBAAgB,IAAI,CAACuH,iBAAiB,CAACS,YAAY,CAAC,EAAE;YAC5E;UACF;QAEF,KAAK,YAAY;UACf;YACE,IACEA,aAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,OAAO,GAAGhI,QAAQ,6BAA6B,IAAI,CAACuH,iBAAiB,CAACS,aAAY,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;UACpG;QAEF,KAAK,SAAS;UACZ;YACE,IACEC,OAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEpK,OAAO,GAGTqK,OAAM,CAHJrK,OAAO;YAIT,OAAO,GAAGoC,QAAQ,yBAAyBgG,IAAI,CAACC,SAAS,CAACrI,OAAO,CAAC,GAAGsF,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UACvJ;QAEF,KAAK,QAAQ;UACX;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACElK,MAAM,GAGRmK,QAAM,CAHJnK,MAAM;YAIR,OAAO,GAAGkC,QAAQ,wBAAwBgG,IAAI,CAACC,SAAS,CAACnI,MAAM,CAAC,GAAGoF,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UACrJ;QAEF,KAAK,eAAe;QACpB,KAAK,eAAe;UAClB;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEE,UAAU,GAIZD,QAAM,CAJJC,UAAU;cACVC,KAAK,GAGPF,QAAM,CAHJE,KAAK;YAIP,OAAO,GAAGnI,QAAQ,cAAckI,UAAU,IAAIlC,IAAI,CAACC,SAAS,CAACkC,KAAK,CAAC,GAAGjF,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UACxJ;QAEF,KAAK,SAAS;QACd,KAAK,SAAS;QACd,KAAK,kBAAkB;QACvB,KAAK,kBAAkB;UACrB;YACE,IACEA,cAAY,GAEVjI,KAAK,CAFPiI,YAAY;cACZC,QAAM,GACJlI,KAAK,CADPkI,MAAM;YAER,IACEC,WAAU,GAIZD,QAAM,CAJJC,UAAU;cACVC,MAAK,GAGPF,QAAM,CAHJE,KAAK;YAIP,IAAAC,UAAA,GAAqB9E,QAAQ,CAE7B0E,cAAY,EAAE,IAAI,CAAC;cAAAK,UAAA,GAAAhN,QAAA,CAAA+M,UAAA;cAFPhF,KAAK,GAAAiF,UAAA,CAAAxH,KAAA;YAIjB,IAAIuC,KAAK,CAACnD,MAAM,KAAK,CAAC,EAAE;cACtBmD,KAAK,CAAC3B,IAAI,CAAC,aAAayG,WAAU,IAAIC,MAAK,EAAE,CAAC;YAChD;YAEA,OAAO,GAAGnI,QAAQ,IAAIoD,KAAK,CAACC,IAAI,CAAC,GAAG,CAAC,GAAGH,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UAC1H;QAEF,KAAK,YAAY;UACf;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACE3J,UAAU,GAGZ4J,QAAM,CAHJ5J,UAAU;YAIZ,OAAO,GAAG2B,QAAQ,0BAA0B3B,UAAU,GAAG6E,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UAC3I;QAEF,KAAK,iBAAiB;UACpB;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEM,cAAc,GAGhBL,QAAM,CAHJK,cAAc;YAIhB,OAAO,GAAGtI,QAAQ,0CAA0CgG,IAAI,CAACC,SAAS,CAACqC,cAAc,CAAC,GAAGpF,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UAC/K;QAEF,KAAK,WAAW;UACd;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEG,OAAK,GAGPF,QAAM,CAHJE,KAAK;YAKP,IAAIA,OAAK,KAAK,CAAC,EAAE;cACf,OAAO,GAAGnI,QAAQ,iCAAiCkD,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;YACrI;YAEA,IAAM/H,MAAM,GAAGkI,OAAK,GAAG,CAAC;YACxB,OAAO,GAAGnI,QAAQ,0BAA0BC,MAAM,aAAaA,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,GAAGiD,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UACzK;QAEF,KAAK,UAAU;UACb;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEG,OAAK,GAGPF,QAAM,CAHJE,KAAK;YAKP,IAAIA,OAAK,KAAK,CAAC,EAAE;cACf,OAAO,GAAGnI,QAAQ,gCAAgCkD,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;YACpI;YAEA,OAAO,GAAGhI,QAAQ,+BAA+BmI,OAAK,SAASjF,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UACjJ;QAEF,KAAK,eAAe;UAClB;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEG,OAAK,GAGPF,QAAM,CAHJE,KAAK;YAKP,IAAIA,OAAK,KAAK,CAAC,EAAE;cACf,OAAO,GAAGnI,QAAQ,iCAAiCkD,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;YACrI;YAEA,OAAO,GAAGhI,QAAQ,+BAA+BmI,OAAK,cAAcjF,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UACtJ;QAEF,KAAK,WAAW;UACd;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,cAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEG,OAAK,GAGPF,QAAM,CAHJE,KAAK;YAIP,IAAM3I,GAAG,GAAG2I,OAAK,GAAG,CAAC;YACrB,OAAO,GAAGnI,QAAQ,2BAA2BR,GAAG,aAAaA,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,GAAG0D,iBAAiB,CAAC8E,cAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,cAAY,CAAC,EAAE;UACpK;QAEF,KAAK,UAAU;UACb;YACE,IACEC,QAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEG,OAAK,GAGPF,QAAM,CAHJE,KAAK;YAIP,OAAO,GAAGnI,QAAQ,8BAA8BmI,OAAK,SAASjF,iBAAiB,CAAC8E,eAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,eAAY,CAAC,EAAE;UAChJ;QAEF,KAAK,eAAe;UAClB;YACE,IACEC,SAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEG,OAAK,GAGPF,SAAM,CAHJE,KAAK;YAIP,OAAO,GAAGnI,QAAQ,8BAA8BmI,OAAK,cAAcjF,iBAAiB,CAAC8E,eAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,eAAY,CAAC,EAAE;UACrJ;QAEF,KAAK,aAAa;UAChB;YACE,IACEC,SAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACE3H,CAAC,GAGH4H,SAAM,CAHJ5H,CAAC;YAIH,OAAO,GAAGL,QAAQ,iCAAiCD,KAAK,CAACwI,IAAI,CAAClI,CAAC,CAAC,UAAU6C,iBAAiB,CAAC8E,eAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,eAAY,CAAC,EAAE;UAC5J;QAEF,KAAK,iBAAiB;UACpB;YACE,IACEC,SAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEG,OAAK,GAGPF,SAAM,CAHJE,KAAK;YAIP,OAAO,GAAGnI,QAAQ,8BAA8BmI,OAAK,SAASjF,iBAAiB,CAAC8E,eAAY,CAAC,6BAA6B,IAAI,CAACT,iBAAiB,CAACS,eAAY,CAAC,EAAE;UAClK;QAEF,KAAK,UAAU;UACb;YACE,IACEA,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,OAAO,GAAGhI,QAAQ,iCAAiC,IAAI,CAACuH,iBAAiB,CAACS,eAAY,EAAE,CAAC,UAAU,CAAC,CAAC,QAAQ9E,iBAAiB,CAAC8E,eAAY,CAAC,GAAG;UACjJ;QAEF,KAAK,UAAU;UACb;YACE,IACEA,eAAY,GAEVjI,KAAK,CAFPiI,YAAY;cACZC,SAAM,GACJlI,KAAK,CADPkI,MAAM;YAER,IAAMO,eAAe,GAErBP,SAAM,CAACO,eAAe,CAACzG,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;YACzC,IAAM0G,WAAW,GAAGT,eAAY,IAAI1L,OAAO,CAE3C0L,eAAY,CAAClF,UAAU,IAEvBkF,eAAY,CAAClF,UAAU,CAAC0F,eAAe,CAAC,CAAC;YACzC,OAAO,GAAGxI,QAAQ,yBAAyBwI,eAAe,IAAItF,iBAAiB,CAAC8E,eAAY,CAAC,IAAIS,WAAW,GAAG,gBAAgB,IAAI,CAAClB,iBAAiB,CAACS,eAAY,EAAE,CAAC,YAAY,EAAEQ,eAAe,CAAC,CAAC,EAAE,GAAG,IAAI,CAACZ,wBAAwB,CAACI,eAAY,CAAC,EAAE;UACxP;QAEF,KAAK,sBAAsB;UACzB;YACE,IACEC,SAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEU,kBAAkB,GAGpBT,SAAM,CAHJS,kBAAkB;YAIpB,OAAO,GAAG1I,QAAQ,6BAA6B0I,kBAAkB,IAAIxF,iBAAiB,CAAC8E,eAAY,CAAC,kCAAkC,IAAI,CAACT,iBAAiB,CAACS,eAAY,CAAC,EAAE;UAC9K;QAEF,KAAK,cAAc;UACjB;YACE,IACEC,SAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEf,QAAQ,GAIVgB,SAAM,CAJJhB,QAAQ;cACR0B,IAAI,GAGNV,SAAM,CAHJU,IAAI;YAIN,IAAM7J,YAAY,GAAG6J,IAAI,CAACxD,KAAK,CAAC,GAAG,CAAC,CAACjE,GAAG,CAKxC,UAAAoG,GAAG;cAAA,OAAI,IAAIA,GAAG,CAACsB,IAAI,CAAC,CAAC,GAAG;YAAA,EAAC,CAACvF,IAAI,CAAC,IAAI,CAAC;YACpC,OAAO,GAAGrD,QAAQ,2BAA2BlB,YAAY,mBAAmBmI,QAAQ,eAAe/D,iBAAiB,CAAC8E,eAAY,CAAC,IAAI,IAAI,CAACJ,wBAAwB,CAACI,eAAY,CAAC,EAAE;UACrL;QAEF,KAAK,eAAe;UAClB;YACE,IACEC,SAAM,GAGJlI,KAAK,CAHPkI,MAAM;cACND,eAAY,GAEVjI,KAAK,CAFPiI,YAAY;cACZjH,MAAM,GACJhB,KAAK,CADPgB,MAAM;YAER,IACE8H,YAAY,GAGdZ,SAAM,CAHJY,YAAY;YAId,OAAO,GAAG7I,QAAQ,mBAAmB6I,YAAY,eAAe3F,iBAAiB,CAAC8E,eAAY,CAAC,2CAA2ChC,IAAI,CAACC,SAAS,CAAClF,MAAM,CAACjD,MAAM,CAAC,IAAI,IAAI,CAAC8J,wBAAwB,CAACI,eAAY,CAAC,EAAE;UAC1N;QAEF,KAAK,MAAM;UACT;YACE,IACEA,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAGd,IAAIA,eAAY,IAEhBA,eAAY,CAACxK,IAAI,IAEjBwK,eAAY,CAACxK,IAAI,CAACyC,MAAM,KAAK,CAAC,EAAE;cAC9B,OAAO,GAAGD,QAAQ,cAAc,IAAI,CAACuH,iBAAiB,CAACS,eAAY,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;YACrF;YAEA,OAAO,GAAGhI,QAAQ,6BAA6B,IAAI,CAACuH,iBAAiB,CAACS,eAAY,CAAC,EAAE;UACvF;QAEF,KAAK,OAAO;UACV;YACE,IACEA,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,OAAO,GAAGhI,QAAQ,gCAAgC,IAAI,CAACuH,iBAAiB,CAACS,eAAY,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;UACvG;QAEF,KAAK,KAAK;UACR;YACE,IAAMc,OAAO,GAAGjG,UAAU,CAE1B9C,KAAK,CAACiI,YAAY,CAAC,GAAG,KAAK,IAAI,CAACT,iBAAiB,CAACxH,KAAK,CAACiI,YAAY,CAAC,EAAE,GAAG,EAAE;YAC5E,IAAMe,YAAY,GAAG,IAAI,CAACxB,iBAAiB,CAACxH,KAAK,CAACgB,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;YAE9E,IAAImB,WAAW,CAACnC,KAAK,CAACgB,MAAM,CAAC,EAAE;cAC7B,OAAO,GAAGf,QAAQ,kBAAkB+I,YAAY,GAAGD,OAAO,GAAG;YAC/D;YAEA,IACE/H,OAAM,GAEJhB,KAAK,CAFPgB,MAAM;cACNiH,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,OAAO,GAAGhI,QAAQ,kBAAkB,IAAI,CAACuH,iBAAiB,CAACxG,OAAM,EAAE,KAAK,EAAE,IAAI,CAAC,GAAGiH,eAAY,IAAInF,UAAU,CAACmF,eAAY,CAAC,GAAG,KAAK,IAAI,CAACT,iBAAiB,CAACS,eAAY,CAAC,EAAE,GAAG,EAAE,EAAE;UACjL;QAEF,KAAK,OAAO;QACZ,KAAK,OAAO;UACV;YACE,IACEA,eAAY,GAEVjI,KAAK,CAFPiI,YAAY;cACZnI,QAAQ,GACNE,KAAK,CADPF,QAAQ;YAGV,IAAIA,QAAQ,IAAIA,QAAQ,CAACI,MAAM,GAAG,CAAC,EAAE;cACnC,IAAIF,KAAK,CAACgB,MAAM,CAACd,MAAM,KAAK,CAAC,EAAE;gBAC7B,IAAM+I,SAAS,GAAGnJ,QAAQ,CAACA,QAAQ,CAACI,MAAM,GAAG,CAAC,CAAC;gBAC/C,IAAMgJ,iBAAiB,GAAGpJ,QAAQ,CAACgB,KAAK,CAAC,CAAC,EAAEhB,QAAQ,CAACI,MAAM,GAAG,CAAC,CAAC;gBAChE,OAAO,IAAI,CAAC4H,qBAAqB,CAACnL,MAAM,CAACgF,MAAM,CAAC,CAAC,CAAC,EAAEsH,SAAS,EAAE;kBAC7DnJ,QAAQ,EAAEoJ,iBAAiB;kBAC3BjB,YAAY,EAAEtL,MAAM,CAACgF,MAAM,CAAC,CAAC,CAAC,EAAEsG,eAAY,EAAEgB,SAAS,CAAChB,YAAY;gBACtE,CAAC,CAAC,CAAC;cACL;cAEA,IAAIkB,gBAAgB,GAAGtJ,cAAc,CAACC,QAAQ,CAAC;cAE/C,IAAIqJ,gBAAgB,CAACjJ,MAAM,KAAK,CAAC,EAAE;gBACjC,OAAO,IAAI,CAAC4H,qBAAqB,CAACqB,gBAAgB,CAAC,CAAC,CAAC,CAAC;cACxD;cAEAA,gBAAgB,GAAG5H,yBAAyB,CAAC4H,gBAAgB,CAAC;cAC9D,OAAO,GAAGlJ,QAAQ,6BAA6B,IAAI,CAACuH,iBAAiB,CAACS,eAAY,CAAC,eAAekB,gBAAgB,CAAChI,GAAG,CAKtH,UAAAiI,WAAW;gBAAA,OAAI,MAAMvH,MAAM,CAACkG,MAAI,CAACD,qBAAqB,CAACsB,WAAW,CAAC,EAAE,KAAK,CAAC,EAAE;cAAA,EAAC,CAAC9F,IAAI,CAAC,IAAI,CAAC,EAAE;YAC7F;YAEA,OAAO,GAAGrD,QAAQ,6BAA6B,IAAI,CAACuH,iBAAiB,CAACS,eAAY,CAAC,EAAE;UACvF;QAEF,KAAK,IAAI;UACP;YACE,IACEC,SAAM,GAEJlI,KAAK,CAFPkI,MAAM;cACND,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IACEoB,cAAc,GAGhBnB,SAAM,CAHJmB,cAAc;YAIhB,OAAO,GAAGpJ,QAAQ,kBAAkBoJ,cAAc,cAAc,IAAI,CAAC7B,iBAAiB,CAACS,eAAY,EAAE,CAACoB,cAAc,CAAC,CAAC,EAAE;UAC1H;QAEF,KAAK,cAAc;UACjB;YACE,IACEzE,OAAO,GAEL5E,KAAK,CAFP4E,OAAO;cACPqD,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,OAAO,GAAGhI,QAAQ,KAAK2E,OAAO,GAAG,IAAI,CAACiD,wBAAwB,CAACI,eAAY,CAAC,EAAE;UAChF;QAIF;UACE;YACE,IACErD,QAAO,GAEL5E,KAAK,CAFP4E,OAAO;cACPqD,eAAY,GACVjI,KAAK,CADPiI,YAAY;YAEd,IAAMqB,WAAW,GAAGrD,IAAI,CAACC,SAAS,CAAClG,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;YAGlD,OAAO,GAAGC,QAAQ,IAAI2E,QAAO,KAAK0E,WAAW,OAAO,IAAI,CAAC9B,iBAAiB,CAACS,eAAY,EAAE,KAAK,CAAC,EAAE;UACnG;MACJ;IACF;EAAC;IAAAjD,GAAA;IAAAlI,KAAA,EAOD,SAAA+H,sBAAsBA,CAAClB,MAAM,EAAE;MAAA,IAAA4F,MAAA;MAC7B,OAAO5F,MAAM,CAACxC,GAAG,CAAC,UAAAnB,KAAK,EAAI;QACzB,IAAIwJ,cAAc,GAAGD,MAAI,CAACzB,qBAAqB,CAAC9H,KAAK,CAAC;QAEtD,IAAIuJ,MAAI,CAAC7E,aAAa,EAAE;UACtB8E,cAAc,GAAGD,MAAI,CAAC7E,aAAa,CAAC8E,cAAc,EAAExJ,KAAK,CAAC;QAC5D;QAEA,OAAO,MAAM6B,MAAM,CAAC2H,cAAc,EAAE,KAAK,CAAC,EAAE;MAC9C,CAAC,CAAC,CAAClG,IAAI,CAAC,IAAI,CAAC;IACf;EAAC;AAAA,EAAAzH,gBAAA,CAr3B2BiJ,KAAK;AAy3BnC,IAAI2E,QAAQ,GAAGhG,eAAe;AAC9B5G,OAAO,CAACE,OAAO,GAAG0M,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
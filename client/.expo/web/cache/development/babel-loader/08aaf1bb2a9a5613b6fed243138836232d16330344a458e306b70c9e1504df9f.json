{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { storage } from \"../../../core/config/firebase\";\nimport { formatCurrency } from \"../../../shared/utils/currency\";\nimport { logger } from \"../../../shared/utils/logger\";\nvar uploadImage = function () {\n  var _ref = _asyncToGenerator(function* (file) {\n    var storageRef = storage().ref(`receipts/${Date.now()}_${file.name}`);\n    yield storageRef.put(file);\n    return yield storageRef.getDownloadURL();\n  });\n  return function uploadImage(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var processReceiptImage = function () {\n  var _ref2 = _asyncToGenerator(function* (file) {\n    try {\n      var optimizedImage = yield optimizeImage(file);\n      var imageUrl = yield uploadImage(optimizedImage);\n      var response = yield fetch('/api/receipts/process', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          imageUrl: imageUrl\n        })\n      });\n      if (!response.ok) {\n        throw new Error('Failed to process receipt');\n      }\n      var data = yield response.json();\n      return parseOCRResponse(data);\n    } catch (error) {\n      logger.error('Error processing receipt:', error);\n      throw error;\n    }\n  });\n  return function processReceiptImage(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar optimizeImage = function () {\n  var _ref3 = _asyncToGenerator(function* (file) {\n    try {\n      if (file.size <= 1024 * 1024) return file;\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      var img = new Image();\n      return new Promise(function (resolve, reject) {\n        img.onload = function () {\n          var _calculateDimensions = calculateDimensions(img, 1920),\n            width = _calculateDimensions.width,\n            height = _calculateDimensions.height;\n          canvas.width = width;\n          canvas.height = height;\n          ctx.drawImage(img, 0, 0, width, height);\n          canvas.toBlob(function (blob) {\n            resolve(new File([blob], file.name, {\n              type: 'image/jpeg',\n              lastModified: Date.now()\n            }));\n          }, 'image/jpeg', 0.8);\n        };\n        img.onerror = reject;\n        img.src = URL.createObjectURL(file);\n      });\n    } catch (error) {\n      logger.error('Error optimizing image:', error);\n      return file;\n    }\n  });\n  return function optimizeImage(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar calculateDimensions = function calculateDimensions(img, maxWidth) {\n  var width = img.width;\n  var height = img.height;\n  if (width > maxWidth) {\n    height = Math.round(height * maxWidth / width);\n    width = maxWidth;\n  }\n  return {\n    width: width,\n    height: height\n  };\n};\nvar parseOCRResponse = function parseOCRResponse(data) {\n  try {\n    var text = data.text,\n      confidence = data.confidence,\n      blocks = data.blocks;\n    var receiptData = {\n      merchant: '',\n      date: null,\n      total: 0,\n      items: [],\n      rawText: text,\n      confidence: confidence\n    };\n    var lines = text.split('\\n');\n    for (var i = 0; i < Math.min(3, lines.length); i++) {\n      var line = lines[i].trim();\n      if (line.length > 3 && !line.match(/^[\\d\\W]/)) {\n        receiptData.merchant = line;\n        break;\n      }\n    }\n    var dateRegex = /(\\d{1,2}[-/]\\d{1,2}[-/]\\d{2,4})|(\\d{4}[-/]\\d{1,2}[-/]\\d{1,2})/;\n    for (var _line of lines) {\n      var match = _line.match(dateRegex);\n      if (match) {\n        receiptData.date = new Date(match[0]);\n        break;\n      }\n    }\n    var totalRegex = /tot?al\\s*:?\\s*[$€£]?\\s*(\\d+[.,]\\d{2})/i;\n    for (var _i = lines.length - 1; _i >= 0; _i--) {\n      var _match = lines[_i].match(totalRegex);\n      if (_match) {\n        receiptData.total = parseFloat(_match[1].replace(',', '.'));\n        break;\n      }\n    }\n    var itemRegex = /([A-Za-z0-9\\s&]+)\\s+(?:[\\d]+\\s+)?[$€£]?(\\d+[.,]\\d{2})/;\n    var currentItems = [];\n    for (var _line2 of lines) {\n      var _match2 = _line2.match(itemRegex);\n      if (_match2 && !_line2.toLowerCase().includes('total')) {\n        currentItems.push({\n          name: _match2[1].trim(),\n          price: parseFloat(_match2[2].replace(',', '.'))\n        });\n      }\n    }\n    receiptData.items = currentItems.filter(function (item) {\n      return item.price > 0 && item.price < receiptData.total * 1.5;\n    });\n    return receiptData;\n  } catch (error) {\n    logger.error('Error parsing OCR response:', error);\n    throw new Error('Failed to parse receipt data');\n  }\n};\nexport var validateOCRResult = function validateOCRResult(data) {\n  var errors = [];\n  if (!data.merchant) {\n    errors.push('Could not identify merchant name');\n  }\n  if (!data.date) {\n    errors.push('Could not identify receipt date');\n  }\n  if (!data.total || data.total <= 0) {\n    errors.push('Could not identify total amount');\n  }\n  if (data.items.length === 0) {\n    errors.push('No items could be identified');\n  }\n  return {\n    isValid: errors.length === 0,\n    errors: errors,\n    confidence: data.confidence\n  };\n};\nexport var extractTotalFromText = function extractTotalFromText(text) {\n  try {\n    var lines = text.split('\\n');\n    var totalRegex = /tot?al\\s*:?\\s*[$€£]?\\s*(\\d+[.,]\\d{2})/i;\n    for (var i = lines.length - 1; i >= 0; i--) {\n      var match = lines[i].match(totalRegex);\n      if (match) {\n        return parseFloat(match[1].replace(',', '.'));\n      }\n    }\n    return null;\n  } catch (error) {\n    logger.error('Error extracting total:', error);\n    return null;\n  }\n};","map":{"version":3,"names":["storage","formatCurrency","logger","uploadImage","_ref","_asyncToGenerator","file","storageRef","ref","Date","now","name","put","getDownloadURL","_x","apply","arguments","processReceiptImage","_ref2","optimizedImage","optimizeImage","imageUrl","response","fetch","method","headers","body","JSON","stringify","ok","Error","data","json","parseOCRResponse","error","_x2","_ref3","size","canvas","document","createElement","ctx","getContext","img","Image","Promise","resolve","reject","onload","_calculateDimensions","calculateDimensions","width","height","drawImage","toBlob","blob","File","type","lastModified","onerror","src","URL","createObjectURL","_x3","maxWidth","Math","round","text","confidence","blocks","receiptData","merchant","date","total","items","rawText","lines","split","i","min","length","line","trim","match","dateRegex","totalRegex","parseFloat","replace","itemRegex","currentItems","toLowerCase","includes","push","price","filter","item","validateOCRResult","errors","isValid","extractTotalFromText"],"sources":["C:/Users/user/Documents/app.v3/client/src/features/documents/services/ocr.js"],"sourcesContent":["import { storage } from '../../../core/config/firebase'; //correct\r\nimport { formatCurrency } from '../../../shared/utils/currency'; //correct\r\nimport { logger } from '../../../shared/utils/logger'; //correct\r\n\r\nconst uploadImage = async (file) => {\r\n  const storageRef = storage().ref(`receipts/${Date.now()}_${file.name}`);\r\n  await storageRef.put(file);\r\n  return await storageRef.getDownloadURL();\r\n};\r\n\r\nexport const processReceiptImage = async file => {\r\n  try {\r\n    // First compress and optimize the image if needed\r\n    const optimizedImage = await optimizeImage(file);\r\n\r\n    // Upload to storage and get URL\r\n    const imageUrl = await uploadImage(optimizedImage);\r\n\r\n    // Process with OCR service\r\n    const response = await fetch('/api/receipts/process', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({ imageUrl }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to process receipt');\r\n    }\r\n\r\n    const data = await response.json();\r\n    return parseOCRResponse(data);\r\n  } catch (error) {\r\n    logger.error('Error processing receipt:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst optimizeImage = async file => {\r\n  try {\r\n    // Return original file if it's already optimized\r\n    if (file.size <= 1024 * 1024) return file;\r\n\r\n    // Create canvas for image compression\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    const img = new Image();\r\n\r\n    // Create a promise to handle image loading\r\n    return new Promise((resolve, reject) => {\r\n      img.onload = () => {\r\n        // Calculate new dimensions while maintaining aspect ratio\r\n        const { width, height } = calculateDimensions(img, 1920); // Max width 1920px\r\n\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n\r\n        // Draw and compress image\r\n        ctx.drawImage(img, 0, 0, width, height);\r\n\r\n        // Convert to blob\r\n        canvas.toBlob(\r\n          blob => {\r\n            resolve(\r\n              new File([blob], file.name, {\r\n                type: 'image/jpeg',\r\n                lastModified: Date.now(),\r\n              })\r\n            );\r\n          },\r\n          'image/jpeg',\r\n          0.8 // Quality setting\r\n        );\r\n      };\r\n\r\n      img.onerror = reject;\r\n      img.src = URL.createObjectURL(file);\r\n    });\r\n  } catch (error) {\r\n    logger.error('Error optimizing image:', error);\r\n    return file; // Return original file if optimization fails\r\n  }\r\n};\r\n\r\nconst calculateDimensions = (img, maxWidth) => {\r\n  let width = img.width;\r\n  let height = img.height;\r\n\r\n  if (width > maxWidth) {\r\n    height = Math.round((height * maxWidth) / width);\r\n    width = maxWidth;\r\n  }\r\n\r\n  return { width, height };\r\n};\r\n\r\nconst parseOCRResponse = data => {\r\n  try {\r\n    const { text, confidence, blocks } = data;\r\n\r\n    // Initialize receipt data\r\n    const receiptData = {\r\n      merchant: '',\r\n      date: null,\r\n      total: 0,\r\n      items: [],\r\n      rawText: text,\r\n      confidence,\r\n    };\r\n\r\n    // Extract merchant name (usually in the first few lines)\r\n    const lines = text.split('\\n');\r\n    for (let i = 0; i < Math.min(3, lines.length); i++) {\r\n      const line = lines[i].trim();\r\n      if (line.length > 3 && !line.match(/^[\\d\\W]/)) {\r\n        receiptData.merchant = line;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Extract date using common formats\r\n    const dateRegex = /(\\d{1,2}[-/]\\d{1,2}[-/]\\d{2,4})|(\\d{4}[-/]\\d{1,2}[-/]\\d{1,2})/;\r\n    for (const line of lines) {\r\n      const match = line.match(dateRegex);\r\n      if (match) {\r\n        receiptData.date = new Date(match[0]);\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Extract total amount\r\n    const totalRegex = /tot?al\\s*:?\\s*[$€£]?\\s*(\\d+[.,]\\d{2})/i;\r\n    for (let i = lines.length - 1; i >= 0; i--) {\r\n      const match = lines[i].match(totalRegex);\r\n      if (match) {\r\n        receiptData.total = parseFloat(match[1].replace(',', '.'));\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Extract items\r\n    const itemRegex = /([A-Za-z0-9\\s&]+)\\s+(?:[\\d]+\\s+)?[$€£]?(\\d+[.,]\\d{2})/;\r\n    const currentItems = [];\r\n    for (const line of lines) {\r\n      const match = line.match(itemRegex);\r\n      if (match && !line.toLowerCase().includes('total')) {\r\n        currentItems.push({\r\n          name: match[1].trim(),\r\n          price: parseFloat(match[2].replace(',', '.')),\r\n        });\r\n      }\r\n    }\r\n\r\n    // Filter out likely non-items (prices too high or low)\r\n    receiptData.items = currentItems.filter(\r\n      item => item.price > 0 && item.price < receiptData.total * 1.5\r\n    );\r\n\r\n    return receiptData;\r\n  } catch (error) {\r\n    logger.error('Error parsing OCR response:', error);\r\n    throw new Error('Failed to parse receipt data');\r\n  }\r\n};\r\n\r\nexport const validateOCRResult = data => {\r\n  const errors = [];\r\n\r\n  if (!data.merchant) {\r\n    errors.push('Could not identify merchant name');\r\n  }\r\n\r\n  if (!data.date) {\r\n    errors.push('Could not identify receipt date');\r\n  }\r\n\r\n  if (!data.total || data.total <= 0) {\r\n    errors.push('Could not identify total amount');\r\n  }\r\n\r\n  if (data.items.length === 0) {\r\n    errors.push('No items could be identified');\r\n  }\r\n\r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n    confidence: data.confidence,\r\n  };\r\n};\r\n\r\nexport const extractTotalFromText = text => {\r\n  try {\r\n    const lines = text.split('\\n');\r\n    const totalRegex = /tot?al\\s*:?\\s*[$€£]?\\s*(\\d+[.,]\\d{2})/i;\r\n\r\n    for (let i = lines.length - 1; i >= 0; i--) {\r\n      const match = lines[i].match(totalRegex);\r\n      if (match) {\r\n        return parseFloat(match[1].replace(',', '.'));\r\n      }\r\n    }\r\n\r\n    return null;\r\n  } catch (error) {\r\n    logger.error('Error extracting total:', error);\r\n    return null;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}